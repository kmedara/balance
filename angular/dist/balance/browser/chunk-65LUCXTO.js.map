{"version":3,"sources":["node_modules/@angular/platform-browser/fesm2022/_dom_renderer-chunk.mjs","node_modules/@angular/platform-browser/fesm2022/_browser-chunk.mjs","node_modules/@angular/common/fesm2022/_module-chunk.mjs","node_modules/@angular/common/fesm2022/http.mjs","node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs","node_modules/@angular/router/fesm2022/_router-chunk.mjs","node_modules/@angular/router/fesm2022/_router_module-chunk.mjs"],"sourcesContent":["/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { DOCUMENT, ɵgetDOM as _getDOM } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, ɵRuntimeError as _RuntimeError, APP_ID, CSP_NONCE, PLATFORM_ID, Optional, ViewEncapsulation, ɵTracingService as _TracingService, RendererStyleFlags2, ɵallLeavingAnimations as _allLeavingAnimations } from '@angular/core';\nclass EventManagerPlugin {\n  _doc;\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  manager;\n}\nlet DomEventsPlugin = /*#__PURE__*/(() => {\n  class DomEventsPlugin extends EventManagerPlugin {\n    constructor(doc) {\n      super(doc);\n    }\n    supports(eventName) {\n      return true;\n    }\n    addEventListener(element, eventName, handler, options) {\n      element.addEventListener(eventName, handler, options);\n      return () => this.removeEventListener(element, eventName, handler, options);\n    }\n    removeEventListener(target, eventName, callback, options) {\n      return target.removeEventListener(eventName, callback, options);\n    }\n    static ɵfac = function DomEventsPlugin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomEventsPlugin)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomEventsPlugin,\n      factory: DomEventsPlugin.ɵfac\n    });\n  }\n  return DomEventsPlugin;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EVENT_MANAGER_PLUGINS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'EventManagerPlugins' : '');\nlet EventManager = /*#__PURE__*/(() => {\n  class EventManager {\n    _zone;\n    _plugins;\n    _eventNameToPlugin = new Map();\n    constructor(plugins, _zone) {\n      this._zone = _zone;\n      plugins.forEach(plugin => {\n        plugin.manager = this;\n      });\n      const otherPlugins = plugins.filter(p => !(p instanceof DomEventsPlugin));\n      this._plugins = otherPlugins.slice().reverse();\n      const domEventPlugin = plugins.find(p => p instanceof DomEventsPlugin);\n      if (domEventPlugin) {\n        this._plugins.push(domEventPlugin);\n      }\n    }\n    addEventListener(element, eventName, handler, options) {\n      const plugin = this._findPluginFor(eventName);\n      return plugin.addEventListener(element, eventName, handler, options);\n    }\n    getZone() {\n      return this._zone;\n    }\n    _findPluginFor(eventName) {\n      let plugin = this._eventNameToPlugin.get(eventName);\n      if (plugin) {\n        return plugin;\n      }\n      const plugins = this._plugins;\n      plugin = plugins.find(plugin => plugin.supports(eventName));\n      if (!plugin) {\n        throw new _RuntimeError(5101, (typeof ngDevMode === 'undefined' || ngDevMode) && `No event manager plugin found for event ${eventName}`);\n      }\n      this._eventNameToPlugin.set(eventName, plugin);\n      return plugin;\n    }\n    static ɵfac = function EventManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || EventManager)(i0.ɵɵinject(EVENT_MANAGER_PLUGINS), i0.ɵɵinject(i0.NgZone));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: EventManager,\n      factory: EventManager.ɵfac\n    });\n  }\n  return EventManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst APP_ID_ATTRIBUTE_NAME = 'ng-app-id';\nfunction removeElements(elements) {\n  for (const element of elements) {\n    element.remove();\n  }\n}\nfunction createStyleElement(style, doc) {\n  const styleElement = doc.createElement('style');\n  styleElement.textContent = style;\n  return styleElement;\n}\nfunction addServerStyles(doc, appId, inline, external) {\n  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"],link[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"]`);\n  if (elements) {\n    for (const styleElement of elements) {\n      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);\n      if (styleElement instanceof HTMLLinkElement) {\n        external.set(styleElement.href.slice(styleElement.href.lastIndexOf('/') + 1), {\n          usage: 0,\n          elements: [styleElement]\n        });\n      } else if (styleElement.textContent) {\n        inline.set(styleElement.textContent, {\n          usage: 0,\n          elements: [styleElement]\n        });\n      }\n    }\n  }\n}\nfunction createLinkElement(url, doc) {\n  const linkElement = doc.createElement('link');\n  linkElement.setAttribute('rel', 'stylesheet');\n  linkElement.setAttribute('href', url);\n  return linkElement;\n}\nlet SharedStylesHost = /*#__PURE__*/(() => {\n  class SharedStylesHost {\n    doc;\n    appId;\n    nonce;\n    inline = new Map();\n    external = new Map();\n    hosts = new Set();\n    constructor(doc, appId, nonce, platformId = {}) {\n      this.doc = doc;\n      this.appId = appId;\n      this.nonce = nonce;\n      addServerStyles(doc, appId, this.inline, this.external);\n      this.hosts.add(doc.head);\n    }\n    addStyles(styles, urls) {\n      for (const value of styles) {\n        this.addUsage(value, this.inline, createStyleElement);\n      }\n      urls?.forEach(value => this.addUsage(value, this.external, createLinkElement));\n    }\n    removeStyles(styles, urls) {\n      for (const value of styles) {\n        this.removeUsage(value, this.inline);\n      }\n      urls?.forEach(value => this.removeUsage(value, this.external));\n    }\n    addUsage(value, usages, creator) {\n      const record = usages.get(value);\n      if (record) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && record.usage === 0) {\n          record.elements.forEach(element => element.setAttribute('ng-style-reused', ''));\n        }\n        record.usage++;\n      } else {\n        usages.set(value, {\n          usage: 1,\n          elements: [...this.hosts].map(host => this.addElement(host, creator(value, this.doc)))\n        });\n      }\n    }\n    removeUsage(value, usages) {\n      const record = usages.get(value);\n      if (record) {\n        record.usage--;\n        if (record.usage <= 0) {\n          removeElements(record.elements);\n          usages.delete(value);\n        }\n      }\n    }\n    ngOnDestroy() {\n      for (const [, {\n        elements\n      }] of [...this.inline, ...this.external]) {\n        removeElements(elements);\n      }\n      this.hosts.clear();\n    }\n    addHost(hostNode) {\n      this.hosts.add(hostNode);\n      for (const [style, {\n        elements\n      }] of this.inline) {\n        elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));\n      }\n      for (const [url, {\n        elements\n      }] of this.external) {\n        elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));\n      }\n    }\n    removeHost(hostNode) {\n      this.hosts.delete(hostNode);\n    }\n    addElement(host, element) {\n      if (this.nonce) {\n        element.setAttribute('nonce', this.nonce);\n      }\n      if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);\n      }\n      return host.appendChild(element);\n    }\n    static ɵfac = function SharedStylesHost_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SharedStylesHost)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(APP_ID), i0.ɵɵinject(CSP_NONCE, 8), i0.ɵɵinject(PLATFORM_ID));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SharedStylesHost,\n      factory: SharedStylesHost.ɵfac\n    });\n  }\n  return SharedStylesHost;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAMESPACE_URIS = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/',\n  'math': 'http://www.w3.org/1998/Math/MathML'\n};\nconst COMPONENT_REGEX = /%COMP%/g;\nconst SOURCEMAP_URL_REGEXP = /\\/\\*#\\s*sourceMappingURL=(.+?)\\s*\\*\\//;\nconst PROTOCOL_REGEXP = /^https?:/;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RemoveStylesOnCompDestroy' : '', {\n  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT\n});\nfunction shimContentAttribute(componentShortId) {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction shimHostAttribute(componentShortId) {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction shimStylesContent(compId, styles) {\n  return styles.map(s => s.replace(COMPONENT_REGEX, compId));\n}\nfunction addBaseHrefToCssSourceMap(baseHref, styles) {\n  if (!baseHref) {\n    return styles;\n  }\n  const absoluteBaseHrefUrl = new URL(baseHref, 'http://localhost');\n  return styles.map(cssContent => {\n    if (!cssContent.includes('sourceMappingURL=')) {\n      return cssContent;\n    }\n    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {\n      if (sourceMapUrl[0] === '/' || sourceMapUrl.startsWith('data:') || PROTOCOL_REGEXP.test(sourceMapUrl)) {\n        return `/*# sourceMappingURL=${sourceMapUrl} */`;\n      }\n      const {\n        pathname: resolvedSourceMapUrl\n      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);\n      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;\n    });\n  });\n}\nlet DomRendererFactory2 = /*#__PURE__*/(() => {\n  class DomRendererFactory2 {\n    eventManager;\n    sharedStylesHost;\n    appId;\n    removeStylesOnCompDestroy;\n    doc;\n    ngZone;\n    nonce;\n    tracingService;\n    rendererByCompId = new Map();\n    defaultRenderer;\n    constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, ngZone, nonce = null, tracingService = null) {\n      this.eventManager = eventManager;\n      this.sharedStylesHost = sharedStylesHost;\n      this.appId = appId;\n      this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n      this.doc = doc;\n      this.ngZone = ngZone;\n      this.nonce = nonce;\n      this.tracingService = tracingService;\n      this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.tracingService);\n    }\n    createRenderer(element, type) {\n      if (!element || !type) {\n        return this.defaultRenderer;\n      }\n      if (typeof ngServerMode !== 'undefined' && ngServerMode && (type.encapsulation === ViewEncapsulation.ShadowDom || type.encapsulation === ViewEncapsulation.ExperimentalIsolatedShadowDom)) {\n        type = {\n          ...type,\n          encapsulation: ViewEncapsulation.Emulated\n        };\n      }\n      const renderer = this.getOrCreateRenderer(element, type);\n      if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n        renderer.applyToHost(element);\n      } else if (renderer instanceof NoneEncapsulationDomRenderer) {\n        renderer.applyStyles();\n      }\n      return renderer;\n    }\n    getOrCreateRenderer(element, type) {\n      const rendererByCompId = this.rendererByCompId;\n      let renderer = rendererByCompId.get(type.id);\n      if (!renderer) {\n        const doc = this.doc;\n        const ngZone = this.ngZone;\n        const eventManager = this.eventManager;\n        const sharedStylesHost = this.sharedStylesHost;\n        const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;\n        const tracingService = this.tracingService;\n        switch (type.encapsulation) {\n          case ViewEncapsulation.Emulated:\n            renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, tracingService);\n            break;\n          case ViewEncapsulation.ShadowDom:\n            return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, tracingService, sharedStylesHost);\n          case ViewEncapsulation.ExperimentalIsolatedShadowDom:\n            return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, tracingService);\n          default:\n            renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, tracingService);\n            break;\n        }\n        rendererByCompId.set(type.id, renderer);\n      }\n      return renderer;\n    }\n    ngOnDestroy() {\n      this.rendererByCompId.clear();\n    }\n    componentReplaced(componentId) {\n      this.rendererByCompId.delete(componentId);\n    }\n    static ɵfac = function DomRendererFactory2_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomRendererFactory2)(i0.ɵɵinject(EventManager), i0.ɵɵinject(SharedStylesHost), i0.ɵɵinject(APP_ID), i0.ɵɵinject(REMOVE_STYLES_ON_COMPONENT_DESTROY), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(CSP_NONCE), i0.ɵɵinject(_TracingService, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomRendererFactory2,\n      factory: DomRendererFactory2.ɵfac\n    });\n  }\n  return DomRendererFactory2;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultDomRenderer2 {\n  eventManager;\n  doc;\n  ngZone;\n  tracingService;\n  data = /*#__PURE__*/Object.create(null);\n  throwOnSyntheticProps = true;\n  constructor(eventManager, doc, ngZone, tracingService) {\n    this.eventManager = eventManager;\n    this.doc = doc;\n    this.ngZone = ngZone;\n    this.tracingService = tracingService;\n  }\n  destroy() {}\n  destroyNode = null;\n  createElement(name, namespace) {\n    if (namespace) {\n      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n    return this.doc.createElement(name);\n  }\n  createComment(value) {\n    return this.doc.createComment(value);\n  }\n  createText(value) {\n    return this.doc.createTextNode(value);\n  }\n  appendChild(parent, newChild) {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(newChild);\n  }\n  insertBefore(parent, newChild, refChild) {\n    if (parent) {\n      const targetParent = isTemplateNode(parent) ? parent.content : parent;\n      targetParent.insertBefore(newChild, refChild);\n    }\n  }\n  removeChild(_parent, oldChild) {\n    oldChild.remove();\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    let el = typeof selectorOrNode === 'string' ? this.doc.querySelector(selectorOrNode) : selectorOrNode;\n    if (!el) {\n      throw new _RuntimeError(-5104, (typeof ngDevMode === 'undefined' || ngDevMode) && `The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n    return el;\n  }\n  parentNode(node) {\n    return node.parentNode;\n  }\n  nextSibling(node) {\n    return node.nextSibling;\n  }\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      name = namespace + ':' + name;\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n  addClass(el, name) {\n    el.classList.add(name);\n  }\n  removeClass(el, name) {\n    el.classList.remove(name);\n  }\n  setStyle(el, style, value, flags) {\n    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n  removeStyle(el, style, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      el.style[style] = '';\n    }\n  }\n  setProperty(el, name, value) {\n    if (el == null) {\n      return;\n    }\n    (typeof ngDevMode === 'undefined' || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n  setValue(node, value) {\n    node.nodeValue = value;\n  }\n  listen(target, event, callback, options) {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      target = _getDOM().getGlobalEventTarget(this.doc, target);\n      if (!target) {\n        throw new _RuntimeError(5102, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unsupported event target ${target} for event ${event}`);\n      }\n    }\n    let wrappedCallback = this.decoratePreventDefault(callback);\n    if (this.tracingService?.wrapEventListener) {\n      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);\n    }\n    return this.eventManager.addEventListener(target, event, wrappedCallback, options);\n  }\n  decoratePreventDefault(eventHandler) {\n    return event => {\n      if (event === '__ngUnwrap__') {\n        return eventHandler;\n      }\n      const allowDefaultBehavior = typeof ngServerMode !== 'undefined' && ngServerMode ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);\n      if (allowDefaultBehavior === false) {\n        event.preventDefault();\n      }\n      return undefined;\n    };\n  }\n}\nconst AT_CHARCODE = /*#__PURE__*/(() => '@'.charCodeAt(0))();\nfunction checkNoSyntheticProp(name, nameKind) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new _RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Make sure \\`provideAnimationsAsync()\\`, \\`provideAnimations()\\` or \\`provideNoopAnimations()\\` call was added to a list of providers used to bootstrap an application.\n  - There is a corresponding animation configuration named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.dev/api/core/Component#animations).`);\n  }\n}\nfunction isTemplateNode(node) {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  hostEl;\n  sharedStylesHost;\n  shadowRoot;\n  constructor(eventManager, hostEl, component, doc, ngZone, nonce, tracingService, sharedStylesHost) {\n    super(eventManager, doc, ngZone, tracingService);\n    this.hostEl = hostEl;\n    this.sharedStylesHost = sharedStylesHost;\n    this.shadowRoot = hostEl.attachShadow({\n      mode: 'open'\n    });\n    if (this.sharedStylesHost) {\n      this.sharedStylesHost.addHost(this.shadowRoot);\n    }\n    let styles = component.styles;\n    if (ngDevMode) {\n      const baseHref = _getDOM().getBaseHref(doc) ?? '';\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n    styles = shimStylesContent(component.id, styles);\n    for (const style of styles) {\n      const styleEl = document.createElement('style');\n      if (nonce) {\n        styleEl.setAttribute('nonce', nonce);\n      }\n      styleEl.textContent = style;\n      this.shadowRoot.appendChild(styleEl);\n    }\n    const styleUrls = component.getExternalStyles?.();\n    if (styleUrls) {\n      for (const styleUrl of styleUrls) {\n        const linkEl = createLinkElement(styleUrl, doc);\n        if (nonce) {\n          linkEl.setAttribute('nonce', nonce);\n        }\n        this.shadowRoot.appendChild(linkEl);\n      }\n    }\n  }\n  nodeOrShadowRoot(node) {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n  appendChild(parent, newChild) {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  insertBefore(parent, newChild, refChild) {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  removeChild(_parent, oldChild) {\n    return super.removeChild(null, oldChild);\n  }\n  parentNode(node) {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n  destroy() {\n    if (this.sharedStylesHost) {\n      this.sharedStylesHost.removeHost(this.shadowRoot);\n    }\n  }\n}\nclass NoneEncapsulationDomRenderer extends DefaultDomRenderer2 {\n  sharedStylesHost;\n  removeStylesOnCompDestroy;\n  styles;\n  styleUrls;\n  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, tracingService, compId) {\n    super(eventManager, doc, ngZone, tracingService);\n    this.sharedStylesHost = sharedStylesHost;\n    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n    let styles = component.styles;\n    if (ngDevMode) {\n      const baseHref = _getDOM().getBaseHref(doc) ?? '';\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n    this.styles = compId ? shimStylesContent(compId, styles) : styles;\n    this.styleUrls = component.getExternalStyles?.(compId);\n  }\n  applyStyles() {\n    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);\n  }\n  destroy() {\n    if (!this.removeStylesOnCompDestroy) {\n      return;\n    }\n    if (_allLeavingAnimations.size === 0) {\n      this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);\n    }\n  }\n}\nclass EmulatedEncapsulationDomRenderer2 extends NoneEncapsulationDomRenderer {\n  contentAttr;\n  hostAttr;\n  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, tracingService) {\n    const compId = appId + '-' + component.id;\n    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, tracingService, compId);\n    this.contentAttr = shimContentAttribute(compId);\n    this.hostAttr = shimHostAttribute(compId);\n  }\n  applyToHost(element) {\n    this.applyStyles();\n    this.setAttribute(element, this.hostAttr, '');\n  }\n  createElement(parent, name) {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\nexport { DomEventsPlugin, DomRendererFactory2, EVENT_MANAGER_PLUGINS, EventManager, EventManagerPlugin, REMOVE_STYLES_ON_COMPONENT_DESTROY, SharedStylesHost };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { ɵDomAdapter as _DomAdapter, ɵsetRootDomAdapter as _setRootDomAdapter, ɵparseCookieValue as _parseCookieValue, ɵgetDOM as _getDOM, DOCUMENT, ɵPLATFORM_BROWSER_ID as _PLATFORM_BROWSER_ID, XhrFactory, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ɵglobal as _global, ɵRuntimeError as _RuntimeError, Injectable, Inject, ɵinternalCreateApplication as _internalCreateApplication, ɵresolveComponentResources as _resolveComponentResources, PLATFORM_ID, PLATFORM_INITIALIZER, createPlatformFactory, platformCore, InjectionToken, ɵTESTABILITY_GETTER as _TESTABILITY_GETTER, ɵTESTABILITY as _TESTABILITY, Testability, ɵINJECTOR_SCOPE as _INJECTOR_SCOPE, ErrorHandler, RendererFactory2, inject, ApplicationModule, NgModule, ɵsetDocument as _setDocument } from '@angular/core';\nimport { EventManagerPlugin, EVENT_MANAGER_PLUGINS, DomEventsPlugin, DomRendererFactory2, SharedStylesHost, EventManager } from './_dom_renderer-chunk.mjs';\nclass BrowserDomAdapter extends _DomAdapter {\n  supportsDOMEvents = true;\n  static makeCurrent() {\n    _setRootDomAdapter(new BrowserDomAdapter());\n  }\n  onAndCancel(el, evt, listener, options) {\n    el.addEventListener(evt, listener, options);\n    return () => {\n      el.removeEventListener(evt, listener, options);\n    };\n  }\n  dispatchEvent(el, evt) {\n    el.dispatchEvent(evt);\n  }\n  remove(node) {\n    node.remove();\n  }\n  createElement(tagName, doc) {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  createHtmlDocument() {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  getDefaultDocument() {\n    return document;\n  }\n  isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n  isShadowRoot(node) {\n    return node instanceof DocumentFragment;\n  }\n  getGlobalEventTarget(doc, target) {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  getBaseHref(doc) {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  resetBaseElement() {\n    baseElement = null;\n  }\n  getUserAgent() {\n    return window.navigator.userAgent;\n  }\n  getCookie(name) {\n    return _parseCookieValue(document.cookie, name);\n  }\n}\nlet baseElement = null;\nfunction getBaseElementHref() {\n  baseElement = baseElement || document.head.querySelector('base');\n  return baseElement ? baseElement.getAttribute('href') : null;\n}\nfunction relativePath(url) {\n  return new URL(url, document.baseURI).pathname;\n}\nclass BrowserGetTestability {\n  addToWindow(registry) {\n    _global['getAngularTestability'] = (elem, findInAncestors = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new _RuntimeError(5103, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Could not find testability for element.');\n      }\n      return testability;\n    };\n    _global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n    _global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n    const whenAllStable = callback => {\n      const testabilities = _global['getAllAngularTestabilities']();\n      let count = testabilities.length;\n      const decrement = function () {\n        count--;\n        if (count == 0) {\n          callback();\n        }\n      };\n      testabilities.forEach(testability => {\n        testability.whenStable(decrement);\n      });\n    };\n    if (!_global['frameworkStabilizers']) {\n      _global['frameworkStabilizers'] = [];\n    }\n    _global['frameworkStabilizers'].push(whenAllStable);\n  }\n  findTestabilityInTree(registry, elem, findInAncestors) {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (_getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, elem.host, true);\n    }\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n}\nlet BrowserXhr = /*#__PURE__*/(() => {\n  class BrowserXhr {\n    build() {\n      return new XMLHttpRequest();\n    }\n    static ɵfac = function BrowserXhr_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BrowserXhr)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: BrowserXhr,\n      factory: BrowserXhr.ɵfac\n    });\n  }\n  return BrowserXhr;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\nconst _keyMap = {\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n};\nconst MODIFIER_KEY_GETTERS = {\n  'alt': event => event.altKey,\n  'control': event => event.ctrlKey,\n  'meta': event => event.metaKey,\n  'shift': event => event.shiftKey\n};\nlet KeyEventsPlugin = /*#__PURE__*/(() => {\n  class KeyEventsPlugin extends EventManagerPlugin {\n    constructor(doc) {\n      super(doc);\n    }\n    supports(eventName) {\n      return KeyEventsPlugin.parseEventName(eventName) != null;\n    }\n    addEventListener(element, eventName, handler, options) {\n      const parsedEvent = KeyEventsPlugin.parseEventName(eventName);\n      const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n      return this.manager.getZone().runOutsideAngular(() => {\n        return _getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler, options);\n      });\n    }\n    static parseEventName(eventName) {\n      const parts = eventName.toLowerCase().split('.');\n      const domEventName = parts.shift();\n      if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n        return null;\n      }\n      const key = KeyEventsPlugin._normalizeKey(parts.pop());\n      let fullKey = '';\n      let codeIX = parts.indexOf('code');\n      if (codeIX > -1) {\n        parts.splice(codeIX, 1);\n        fullKey = 'code.';\n      }\n      MODIFIER_KEYS.forEach(modifierName => {\n        const index = parts.indexOf(modifierName);\n        if (index > -1) {\n          parts.splice(index, 1);\n          fullKey += modifierName + '.';\n        }\n      });\n      fullKey += key;\n      if (parts.length != 0 || key.length === 0) {\n        return null;\n      }\n      const result = {};\n      result['domEventName'] = domEventName;\n      result['fullKey'] = fullKey;\n      return result;\n    }\n    static matchEventFullKeyCode(event, fullKeyCode) {\n      let keycode = _keyMap[event.key] || event.key;\n      let key = '';\n      if (fullKeyCode.indexOf('code.') > -1) {\n        keycode = event.code;\n        key = 'code.';\n      }\n      if (keycode == null || !keycode) return false;\n      keycode = keycode.toLowerCase();\n      if (keycode === ' ') {\n        keycode = 'space';\n      } else if (keycode === '.') {\n        keycode = 'dot';\n      }\n      MODIFIER_KEYS.forEach(modifierName => {\n        if (modifierName !== keycode) {\n          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n          if (modifierGetter(event)) {\n            key += modifierName + '.';\n          }\n        }\n      });\n      key += keycode;\n      return key === fullKeyCode;\n    }\n    static eventCallback(fullKey, handler, zone) {\n      return event => {\n        if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {\n          zone.runGuarded(() => handler(event));\n        }\n      };\n    }\n    static _normalizeKey(keyName) {\n      return keyName === 'esc' ? 'escape' : keyName;\n    }\n    static ɵfac = function KeyEventsPlugin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || KeyEventsPlugin)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: KeyEventsPlugin,\n      factory: KeyEventsPlugin.ɵfac\n    });\n  }\n  return KeyEventsPlugin;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nasync function bootstrapApplication(rootComponent, options, context) {\n  const config = {\n    rootComponent,\n    ...createProvidersConfig(options, context)\n  };\n  if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n    await resolveJitResources();\n  }\n  return _internalCreateApplication(config);\n}\nasync function createApplication(options, context) {\n  if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n    await resolveJitResources();\n  }\n  return _internalCreateApplication(createProvidersConfig(options, context));\n}\nfunction createProvidersConfig(options, context) {\n  return {\n    platformRef: context?.platformRef,\n    appProviders: [...BROWSER_MODULE_PROVIDERS, ...(options?.providers ?? [])],\n    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS\n  };\n}\nasync function resolveJitResources() {\n  try {\n    return await _resolveComponentResources(fetch);\n  } catch (error) {\n    console.error(error);\n  }\n}\nfunction provideProtractorTestingSupport() {\n  return [...TESTABILITY_PROVIDERS];\n}\nfunction initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n}\nfunction errorHandler() {\n  return new ErrorHandler();\n}\nfunction _document() {\n  _setDocument(document);\n  return document;\n}\nconst INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{\n  provide: PLATFORM_ID,\n  useValue: _PLATFORM_BROWSER_ID\n}, {\n  provide: PLATFORM_INITIALIZER,\n  useValue: initDomAdapter,\n  multi: true\n}, {\n  provide: DOCUMENT,\n  useFactory: _document\n}];\nconst platformBrowser = /*#__PURE__*/createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\nconst BROWSER_MODULE_PROVIDERS_MARKER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'BrowserModule Providers Marker' : '');\nconst TESTABILITY_PROVIDERS = [{\n  provide: _TESTABILITY_GETTER,\n  useClass: BrowserGetTestability\n}, {\n  provide: _TESTABILITY,\n  useClass: Testability\n}, {\n  provide: Testability,\n  useClass: Testability\n}];\nconst BROWSER_MODULE_PROVIDERS = [{\n  provide: _INJECTOR_SCOPE,\n  useValue: 'root'\n}, {\n  provide: ErrorHandler,\n  useFactory: errorHandler\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: DomEventsPlugin,\n  multi: true\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: KeyEventsPlugin,\n  multi: true\n}, DomRendererFactory2, SharedStylesHost, EventManager, {\n  provide: RendererFactory2,\n  useExisting: DomRendererFactory2\n}, {\n  provide: XhrFactory,\n  useClass: BrowserXhr\n}, typeof ngDevMode === 'undefined' || ngDevMode ? {\n  provide: BROWSER_MODULE_PROVIDERS_MARKER,\n  useValue: true\n} : []];\nlet BrowserModule = /*#__PURE__*/(() => {\n  class BrowserModule {\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        const providersAlreadyPresent = inject(BROWSER_MODULE_PROVIDERS_MARKER, {\n          optional: true,\n          skipSelf: true\n        });\n        if (providersAlreadyPresent) {\n          throw new _RuntimeError(5100, `Providers from the \\`BrowserModule\\` have already been loaded. If you need access ` + `to common directives such as NgIf and NgFor, import the \\`CommonModule\\` instead.`);\n        }\n      }\n    }\n    static ɵfac = function BrowserModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BrowserModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: BrowserModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],\n      imports: [CommonModule, ApplicationModule]\n    });\n  }\n  return BrowserModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BrowserDomAdapter, BrowserGetTestability, BrowserModule, KeyEventsPlugin, bootstrapApplication, createApplication, platformBrowser, provideProtractorTestingSupport };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵRuntimeError as _RuntimeError, InjectionToken, inject, NgZone, DestroyRef, Injectable, ɵformatRuntimeError as _formatRuntimeError, ɵTracingService as _TracingService, runInInjectionContext, PendingTasks, ɵConsole as _Console, DOCUMENT, Inject, EnvironmentInjector, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport { switchMap, finalize, concatMap, filter, map } from 'rxjs/operators';\nimport { Observable, from, of } from 'rxjs';\nimport { XhrFactory, parseCookieValue } from './_xhr-chunk.mjs';\nimport { PlatformLocation } from './_platform_location-chunk.mjs';\nclass HttpHeaders {\n  headers;\n  normalizedNames = /*#__PURE__*/new Map();\n  lazyInit;\n  lazyUpdate = null;\n  constructor(headers) {\n    if (!headers) {\n      this.headers = new Map();\n    } else if (typeof headers === 'string') {\n      this.lazyInit = () => {\n        this.headers = new Map();\n        headers.split('\\n').forEach(line => {\n          const index = line.indexOf(':');\n          if (index > 0) {\n            const name = line.slice(0, index);\n            const value = line.slice(index + 1).trim();\n            this.addHeaderEntry(name, value);\n          }\n        });\n      };\n    } else if (typeof Headers !== 'undefined' && headers instanceof Headers) {\n      this.headers = new Map();\n      headers.forEach((value, name) => {\n        this.addHeaderEntry(name, value);\n      });\n    } else {\n      this.lazyInit = () => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          assertValidHeaders(headers);\n        }\n        this.headers = new Map();\n        Object.entries(headers).forEach(([name, values]) => {\n          this.setHeaderEntries(name, values);\n        });\n      };\n    }\n  }\n  has(name) {\n    this.init();\n    return this.headers.has(name.toLowerCase());\n  }\n  get(name) {\n    this.init();\n    const values = this.headers.get(name.toLowerCase());\n    return values && values.length > 0 ? values[0] : null;\n  }\n  keys() {\n    this.init();\n    return Array.from(this.normalizedNames.values());\n  }\n  getAll(name) {\n    this.init();\n    return this.headers.get(name.toLowerCase()) || null;\n  }\n  append(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: 'a'\n    });\n  }\n  set(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: 's'\n    });\n  }\n  delete(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: 'd'\n    });\n  }\n  maybeSetNormalizedName(name, lcName) {\n    if (!this.normalizedNames.has(lcName)) {\n      this.normalizedNames.set(lcName, name);\n    }\n  }\n  init() {\n    if (!!this.lazyInit) {\n      if (this.lazyInit instanceof HttpHeaders) {\n        this.copyFrom(this.lazyInit);\n      } else {\n        this.lazyInit();\n      }\n      this.lazyInit = null;\n      if (!!this.lazyUpdate) {\n        this.lazyUpdate.forEach(update => this.applyUpdate(update));\n        this.lazyUpdate = null;\n      }\n    }\n  }\n  copyFrom(other) {\n    other.init();\n    Array.from(other.headers.keys()).forEach(key => {\n      this.headers.set(key, other.headers.get(key));\n      this.normalizedNames.set(key, other.normalizedNames.get(key));\n    });\n  }\n  clone(update) {\n    const clone = new HttpHeaders();\n    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;\n    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n    return clone;\n  }\n  applyUpdate(update) {\n    const key = update.name.toLowerCase();\n    switch (update.op) {\n      case 'a':\n      case 's':\n        let value = update.value;\n        if (typeof value === 'string') {\n          value = [value];\n        }\n        if (value.length === 0) {\n          return;\n        }\n        this.maybeSetNormalizedName(update.name, key);\n        const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n        base.push(...value);\n        this.headers.set(key, base);\n        break;\n      case 'd':\n        const toDelete = update.value;\n        if (!toDelete) {\n          this.headers.delete(key);\n          this.normalizedNames.delete(key);\n        } else {\n          let existing = this.headers.get(key);\n          if (!existing) {\n            return;\n          }\n          existing = existing.filter(value => toDelete.indexOf(value) === -1);\n          if (existing.length === 0) {\n            this.headers.delete(key);\n            this.normalizedNames.delete(key);\n          } else {\n            this.headers.set(key, existing);\n          }\n        }\n        break;\n    }\n  }\n  addHeaderEntry(name, value) {\n    const key = name.toLowerCase();\n    this.maybeSetNormalizedName(name, key);\n    if (this.headers.has(key)) {\n      this.headers.get(key).push(value);\n    } else {\n      this.headers.set(key, [value]);\n    }\n  }\n  setHeaderEntries(name, values) {\n    const headerValues = (Array.isArray(values) ? values : [values]).map(value => value.toString());\n    const key = name.toLowerCase();\n    this.headers.set(key, headerValues);\n    this.maybeSetNormalizedName(name, key);\n  }\n  forEach(fn) {\n    this.init();\n    Array.from(this.normalizedNames.keys()).forEach(key => fn(this.normalizedNames.get(key), this.headers.get(key)));\n  }\n}\nfunction assertValidHeaders(headers) {\n  for (const [key, value] of Object.entries(headers)) {\n    if (!(typeof value === 'string' || typeof value === 'number') && !Array.isArray(value)) {\n      throw new Error(`Unexpected value of the \\`${key}\\` header provided. ` + `Expecting either a string, a number or an array, but got: \\`${value}\\`.`);\n    }\n  }\n}\nclass HttpContextToken {\n  defaultValue;\n  constructor(defaultValue) {\n    this.defaultValue = defaultValue;\n  }\n}\nclass HttpContext {\n  map = /*#__PURE__*/new Map();\n  set(token, value) {\n    this.map.set(token, value);\n    return this;\n  }\n  get(token) {\n    if (!this.map.has(token)) {\n      this.map.set(token, token.defaultValue());\n    }\n    return this.map.get(token);\n  }\n  delete(token) {\n    this.map.delete(token);\n    return this;\n  }\n  has(token) {\n    return this.map.has(token);\n  }\n  keys() {\n    return this.map.keys();\n  }\n}\nclass HttpUrlEncodingCodec {\n  encodeKey(key) {\n    return standardEncoding(key);\n  }\n  encodeValue(value) {\n    return standardEncoding(value);\n  }\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n}\nfunction paramParser(rawParams, codec) {\n  const map = new Map();\n  if (rawParams.length > 0) {\n    const params = rawParams.replace(/^\\?/, '').split('&');\n    params.forEach(param => {\n      const eqIdx = param.indexOf('=');\n      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ''] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\nconst STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nconst STANDARD_ENCODING_REPLACEMENTS = {\n  '40': '@',\n  '3A': ':',\n  '24': '$',\n  '2C': ',',\n  '3B': ';',\n  '3D': '=',\n  '3F': '?',\n  '2F': '/'\n};\nfunction standardEncoding(v) {\n  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);\n}\nfunction valueToString(value) {\n  return `${value}`;\n}\nclass HttpParams {\n  map;\n  encoder;\n  updates = null;\n  cloneFrom = null;\n  constructor(options = {}) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    if (options.fromString) {\n      if (options.fromObject) {\n        throw new _RuntimeError(2805, ngDevMode && 'Cannot specify both fromString and fromObject.');\n      }\n      this.map = paramParser(options.fromString, this.encoder);\n    } else if (!!options.fromObject) {\n      this.map = new Map();\n      Object.keys(options.fromObject).forEach(key => {\n        const value = options.fromObject[key];\n        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n        this.map.set(key, values);\n      });\n    } else {\n      this.map = null;\n    }\n  }\n  has(param) {\n    this.init();\n    return this.map.has(param);\n  }\n  get(param) {\n    this.init();\n    const res = this.map.get(param);\n    return !!res ? res[0] : null;\n  }\n  getAll(param) {\n    this.init();\n    return this.map.get(param) || null;\n  }\n  keys() {\n    this.init();\n    return Array.from(this.map.keys());\n  }\n  append(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: 'a'\n    });\n  }\n  appendAll(params) {\n    const updates = [];\n    Object.keys(params).forEach(param => {\n      const value = params[param];\n      if (Array.isArray(value)) {\n        value.forEach(_value => {\n          updates.push({\n            param,\n            value: _value,\n            op: 'a'\n          });\n        });\n      } else {\n        updates.push({\n          param,\n          value: value,\n          op: 'a'\n        });\n      }\n    });\n    return this.clone(updates);\n  }\n  set(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: 's'\n    });\n  }\n  delete(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: 'd'\n    });\n  }\n  toString() {\n    this.init();\n    return this.keys().map(key => {\n      const eKey = this.encoder.encodeKey(key);\n      return this.map.get(key).map(value => eKey + '=' + this.encoder.encodeValue(value)).join('&');\n    }).filter(param => param !== '').join('&');\n  }\n  clone(update) {\n    const clone = new HttpParams({\n      encoder: this.encoder\n    });\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat(update);\n    return clone;\n  }\n  init() {\n    if (this.map === null) {\n      this.map = new Map();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach(key => this.map.set(key, this.cloneFrom.map.get(key)));\n      this.updates.forEach(update => {\n        switch (update.op) {\n          case 'a':\n          case 's':\n            const base = (update.op === 'a' ? this.map.get(update.param) : undefined) || [];\n            base.push(valueToString(update.value));\n            this.map.set(update.param, base);\n            break;\n          case 'd':\n            if (update.value !== undefined) {\n              let base = this.map.get(update.param) || [];\n              const idx = base.indexOf(valueToString(update.value));\n              if (idx !== -1) {\n                base.splice(idx, 1);\n              }\n              if (base.length > 0) {\n                this.map.set(update.param, base);\n              } else {\n                this.map.delete(update.param);\n              }\n            } else {\n              this.map.delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = this.updates = null;\n    }\n  }\n}\nfunction mightHaveBody(method) {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\nfunction isArrayBuffer(value) {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\nfunction isBlob(value) {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData(value) {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\nfunction isUrlSearchParams(value) {\n  return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;\n}\nconst CONTENT_TYPE_HEADER = 'Content-Type';\nconst ACCEPT_HEADER = 'Accept';\nconst TEXT_CONTENT_TYPE = 'text/plain';\nconst JSON_CONTENT_TYPE = 'application/json';\nconst ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;\nclass HttpRequest {\n  url;\n  body = null;\n  headers;\n  context;\n  reportProgress = false;\n  withCredentials = false;\n  credentials;\n  keepalive = false;\n  cache;\n  priority;\n  mode;\n  redirect;\n  referrer;\n  integrity;\n  referrerPolicy;\n  responseType = 'json';\n  method;\n  params;\n  urlWithParams;\n  transferCache;\n  timeout;\n  constructor(method, url, third, fourth) {\n    this.url = url;\n    this.method = method.toUpperCase();\n    let options;\n    if (mightHaveBody(this.method) || !!fourth) {\n      this.body = third !== undefined ? third : null;\n      options = fourth;\n    } else {\n      options = third;\n    }\n    if (options) {\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n      this.keepalive = !!options.keepalive;\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n      if (options.headers) {\n        this.headers = options.headers;\n      }\n      if (options.context) {\n        this.context = options.context;\n      }\n      if (options.params) {\n        this.params = options.params;\n      }\n      if (options.priority) {\n        this.priority = options.priority;\n      }\n      if (options.cache) {\n        this.cache = options.cache;\n      }\n      if (options.credentials) {\n        this.credentials = options.credentials;\n      }\n      if (typeof options.timeout === 'number') {\n        if (options.timeout < 1 || !Number.isInteger(options.timeout)) {\n          throw new _RuntimeError(2822, ngDevMode ? '`timeout` must be a positive integer value' : '');\n        }\n        this.timeout = options.timeout;\n      }\n      if (options.mode) {\n        this.mode = options.mode;\n      }\n      if (options.redirect) {\n        this.redirect = options.redirect;\n      }\n      if (options.integrity) {\n        this.integrity = options.integrity;\n      }\n      if (options.referrer) {\n        this.referrer = options.referrer;\n      }\n      if (options.referrerPolicy) {\n        this.referrerPolicy = options.referrerPolicy;\n      }\n      this.transferCache = options.transferCache;\n    }\n    this.headers ??= new HttpHeaders();\n    this.context ??= new HttpContext();\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      const params = this.params.toString();\n      if (params.length === 0) {\n        this.urlWithParams = url;\n      } else {\n        const qIdx = url.indexOf('?');\n        const sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n  serializeBody() {\n    if (this.body === null) {\n      return null;\n    }\n    if (typeof this.body === 'string' || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {\n      return this.body;\n    }\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    if (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    return this.body.toString();\n  }\n  detectContentTypeHeader() {\n    if (this.body === null) {\n      return null;\n    }\n    if (isFormData(this.body)) {\n      return null;\n    }\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    if (typeof this.body === 'string') {\n      return TEXT_CONTENT_TYPE;\n    }\n    if (this.body instanceof HttpParams) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    if (typeof this.body === 'object' || typeof this.body === 'number' || typeof this.body === 'boolean') {\n      return JSON_CONTENT_TYPE;\n    }\n    return null;\n  }\n  clone(update = {}) {\n    const method = update.method || this.method;\n    const url = update.url || this.url;\n    const responseType = update.responseType || this.responseType;\n    const keepalive = update.keepalive ?? this.keepalive;\n    const priority = update.priority || this.priority;\n    const cache = update.cache || this.cache;\n    const mode = update.mode || this.mode;\n    const redirect = update.redirect || this.redirect;\n    const credentials = update.credentials || this.credentials;\n    const referrer = update.referrer || this.referrer;\n    const integrity = update.integrity || this.integrity;\n    const referrerPolicy = update.referrerPolicy || this.referrerPolicy;\n    const transferCache = update.transferCache ?? this.transferCache;\n    const timeout = update.timeout ?? this.timeout;\n    const body = update.body !== undefined ? update.body : this.body;\n    const withCredentials = update.withCredentials ?? this.withCredentials;\n    const reportProgress = update.reportProgress ?? this.reportProgress;\n    let headers = update.headers || this.headers;\n    let params = update.params || this.params;\n    const context = update.context ?? this.context;\n    if (update.setHeaders !== undefined) {\n      headers = Object.keys(update.setHeaders).reduce((headers, name) => headers.set(name, update.setHeaders[name]), headers);\n    }\n    if (update.setParams) {\n      params = Object.keys(update.setParams).reduce((params, param) => params.set(param, update.setParams[param]), params);\n    }\n    return new HttpRequest(method, url, body, {\n      params,\n      headers,\n      context,\n      reportProgress,\n      responseType,\n      withCredentials,\n      transferCache,\n      keepalive,\n      cache,\n      priority,\n      timeout,\n      mode,\n      redirect,\n      credentials,\n      referrer,\n      integrity,\n      referrerPolicy\n    });\n  }\n}\nvar HttpEventType = /*#__PURE__*/function (HttpEventType) {\n  HttpEventType[HttpEventType[\"Sent\"] = 0] = \"Sent\";\n  HttpEventType[HttpEventType[\"UploadProgress\"] = 1] = \"UploadProgress\";\n  HttpEventType[HttpEventType[\"ResponseHeader\"] = 2] = \"ResponseHeader\";\n  HttpEventType[HttpEventType[\"DownloadProgress\"] = 3] = \"DownloadProgress\";\n  HttpEventType[HttpEventType[\"Response\"] = 4] = \"Response\";\n  HttpEventType[HttpEventType[\"User\"] = 5] = \"User\";\n  return HttpEventType;\n}(HttpEventType || {});\nclass HttpResponseBase {\n  headers;\n  status;\n  statusText;\n  url;\n  ok;\n  type;\n  redirected;\n  responseType;\n  constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== undefined ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n    this.redirected = init.redirected;\n    this.responseType = init.responseType;\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n}\nclass HttpHeaderResponse extends HttpResponseBase {\n  constructor(init = {}) {\n    super(init);\n  }\n  type = HttpEventType.ResponseHeader;\n  clone(update = {}) {\n    return new HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined\n    });\n  }\n}\nclass HttpResponse extends HttpResponseBase {\n  body;\n  constructor(init = {}) {\n    super(init);\n    this.body = init.body !== undefined ? init.body : null;\n  }\n  type = HttpEventType.Response;\n  clone(update = {}) {\n    return new HttpResponse({\n      body: update.body !== undefined ? update.body : this.body,\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n      redirected: update.redirected ?? this.redirected,\n      responseType: update.responseType ?? this.responseType\n    });\n  }\n}\nclass HttpErrorResponse extends HttpResponseBase {\n  name = 'HttpErrorResponse';\n  message;\n  error;\n  ok = false;\n  constructor(init) {\n    super(init, 0, 'Unknown Error');\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n    } else {\n      this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n    }\n    this.error = init.error || null;\n  }\n}\nconst HTTP_STATUS_CODE_OK = 200;\nconst HTTP_STATUS_CODE_NO_CONTENT = 204;\nvar HttpStatusCode = /*#__PURE__*/function (HttpStatusCode) {\n  HttpStatusCode[HttpStatusCode[\"Continue\"] = 100] = \"Continue\";\n  HttpStatusCode[HttpStatusCode[\"SwitchingProtocols\"] = 101] = \"SwitchingProtocols\";\n  HttpStatusCode[HttpStatusCode[\"Processing\"] = 102] = \"Processing\";\n  HttpStatusCode[HttpStatusCode[\"EarlyHints\"] = 103] = \"EarlyHints\";\n  HttpStatusCode[HttpStatusCode[\"Ok\"] = 200] = \"Ok\";\n  HttpStatusCode[HttpStatusCode[\"Created\"] = 201] = \"Created\";\n  HttpStatusCode[HttpStatusCode[\"Accepted\"] = 202] = \"Accepted\";\n  HttpStatusCode[HttpStatusCode[\"NonAuthoritativeInformation\"] = 203] = \"NonAuthoritativeInformation\";\n  HttpStatusCode[HttpStatusCode[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCode[HttpStatusCode[\"ResetContent\"] = 205] = \"ResetContent\";\n  HttpStatusCode[HttpStatusCode[\"PartialContent\"] = 206] = \"PartialContent\";\n  HttpStatusCode[HttpStatusCode[\"MultiStatus\"] = 207] = \"MultiStatus\";\n  HttpStatusCode[HttpStatusCode[\"AlreadyReported\"] = 208] = \"AlreadyReported\";\n  HttpStatusCode[HttpStatusCode[\"ImUsed\"] = 226] = \"ImUsed\";\n  HttpStatusCode[HttpStatusCode[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n  HttpStatusCode[HttpStatusCode[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n  HttpStatusCode[HttpStatusCode[\"Found\"] = 302] = \"Found\";\n  HttpStatusCode[HttpStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\n  HttpStatusCode[HttpStatusCode[\"NotModified\"] = 304] = \"NotModified\";\n  HttpStatusCode[HttpStatusCode[\"UseProxy\"] = 305] = \"UseProxy\";\n  HttpStatusCode[HttpStatusCode[\"Unused\"] = 306] = \"Unused\";\n  HttpStatusCode[HttpStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n  HttpStatusCode[HttpStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n  HttpStatusCode[HttpStatusCode[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCode[HttpStatusCode[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCode[HttpStatusCode[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n  HttpStatusCode[HttpStatusCode[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCode[HttpStatusCode[\"NotFound\"] = 404] = \"NotFound\";\n  HttpStatusCode[HttpStatusCode[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n  HttpStatusCode[HttpStatusCode[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n  HttpStatusCode[HttpStatusCode[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n  HttpStatusCode[HttpStatusCode[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCode[HttpStatusCode[\"Conflict\"] = 409] = \"Conflict\";\n  HttpStatusCode[HttpStatusCode[\"Gone\"] = 410] = \"Gone\";\n  HttpStatusCode[HttpStatusCode[\"LengthRequired\"] = 411] = \"LengthRequired\";\n  HttpStatusCode[HttpStatusCode[\"PreconditionFailed\"] = 412] = \"PreconditionFailed\";\n  HttpStatusCode[HttpStatusCode[\"PayloadTooLarge\"] = 413] = \"PayloadTooLarge\";\n  HttpStatusCode[HttpStatusCode[\"UriTooLong\"] = 414] = \"UriTooLong\";\n  HttpStatusCode[HttpStatusCode[\"UnsupportedMediaType\"] = 415] = \"UnsupportedMediaType\";\n  HttpStatusCode[HttpStatusCode[\"RangeNotSatisfiable\"] = 416] = \"RangeNotSatisfiable\";\n  HttpStatusCode[HttpStatusCode[\"ExpectationFailed\"] = 417] = \"ExpectationFailed\";\n  HttpStatusCode[HttpStatusCode[\"ImATeapot\"] = 418] = \"ImATeapot\";\n  HttpStatusCode[HttpStatusCode[\"MisdirectedRequest\"] = 421] = \"MisdirectedRequest\";\n  HttpStatusCode[HttpStatusCode[\"UnprocessableEntity\"] = 422] = \"UnprocessableEntity\";\n  HttpStatusCode[HttpStatusCode[\"Locked\"] = 423] = \"Locked\";\n  HttpStatusCode[HttpStatusCode[\"FailedDependency\"] = 424] = \"FailedDependency\";\n  HttpStatusCode[HttpStatusCode[\"TooEarly\"] = 425] = \"TooEarly\";\n  HttpStatusCode[HttpStatusCode[\"UpgradeRequired\"] = 426] = \"UpgradeRequired\";\n  HttpStatusCode[HttpStatusCode[\"PreconditionRequired\"] = 428] = \"PreconditionRequired\";\n  HttpStatusCode[HttpStatusCode[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n  HttpStatusCode[HttpStatusCode[\"RequestHeaderFieldsTooLarge\"] = 431] = \"RequestHeaderFieldsTooLarge\";\n  HttpStatusCode[HttpStatusCode[\"UnavailableForLegalReasons\"] = 451] = \"UnavailableForLegalReasons\";\n  HttpStatusCode[HttpStatusCode[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  HttpStatusCode[HttpStatusCode[\"NotImplemented\"] = 501] = \"NotImplemented\";\n  HttpStatusCode[HttpStatusCode[\"BadGateway\"] = 502] = \"BadGateway\";\n  HttpStatusCode[HttpStatusCode[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n  HttpStatusCode[HttpStatusCode[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n  HttpStatusCode[HttpStatusCode[\"HttpVersionNotSupported\"] = 505] = \"HttpVersionNotSupported\";\n  HttpStatusCode[HttpStatusCode[\"VariantAlsoNegotiates\"] = 506] = \"VariantAlsoNegotiates\";\n  HttpStatusCode[HttpStatusCode[\"InsufficientStorage\"] = 507] = \"InsufficientStorage\";\n  HttpStatusCode[HttpStatusCode[\"LoopDetected\"] = 508] = \"LoopDetected\";\n  HttpStatusCode[HttpStatusCode[\"NotExtended\"] = 510] = \"NotExtended\";\n  HttpStatusCode[HttpStatusCode[\"NetworkAuthenticationRequired\"] = 511] = \"NetworkAuthenticationRequired\";\n  return HttpStatusCode;\n}(HttpStatusCode || {});\nconst XSSI_PREFIX$1 = /^\\)\\]\\}',?\\n/;\nconst FETCH_BACKEND = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'FETCH_BACKEND' : '');\nlet FetchBackend = /*#__PURE__*/(() => {\n  class FetchBackend {\n    fetchImpl = inject(FetchFactory, {\n      optional: true\n    })?.fetch ?? ((...args) => globalThis.fetch(...args));\n    ngZone = inject(NgZone);\n    destroyRef = inject(DestroyRef);\n    handle(request) {\n      return new Observable(observer => {\n        const aborter = new AbortController();\n        this.doRequest(request, aborter.signal, observer).then(noop, error => observer.error(new HttpErrorResponse({\n          error\n        })));\n        let timeoutId;\n        if (request.timeout) {\n          timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {\n            if (!aborter.signal.aborted) {\n              aborter.abort(new DOMException('signal timed out', 'TimeoutError'));\n            }\n          }, request.timeout));\n        }\n        return () => {\n          if (timeoutId !== undefined) {\n            clearTimeout(timeoutId);\n          }\n          aborter.abort();\n        };\n      });\n    }\n    async doRequest(request, signal, observer) {\n      const init = this.createRequestInit(request);\n      let response;\n      try {\n        const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, {\n          signal,\n          ...init\n        }));\n        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);\n        observer.next({\n          type: HttpEventType.Sent\n        });\n        response = await fetchPromise;\n      } catch (error) {\n        observer.error(new HttpErrorResponse({\n          error,\n          status: error.status ?? 0,\n          statusText: error.statusText,\n          url: request.urlWithParams,\n          headers: error.headers\n        }));\n        return;\n      }\n      const headers = new HttpHeaders(response.headers);\n      const statusText = response.statusText;\n      const url = response.url || request.urlWithParams;\n      let status = response.status;\n      let body = null;\n      if (request.reportProgress) {\n        observer.next(new HttpHeaderResponse({\n          headers,\n          status,\n          statusText,\n          url\n        }));\n      }\n      if (response.body) {\n        const contentLength = response.headers.get('content-length');\n        const chunks = [];\n        const reader = response.body.getReader();\n        let receivedLength = 0;\n        let decoder;\n        let partialText;\n        const reqZone = typeof Zone !== 'undefined' && Zone.current;\n        let canceled = false;\n        await this.ngZone.runOutsideAngular(async () => {\n          while (true) {\n            if (this.destroyRef.destroyed) {\n              await reader.cancel();\n              canceled = true;\n              break;\n            }\n            const {\n              done,\n              value\n            } = await reader.read();\n            if (done) {\n              break;\n            }\n            chunks.push(value);\n            receivedLength += value.length;\n            if (request.reportProgress) {\n              partialText = request.responseType === 'text' ? (partialText ?? '') + (decoder ??= new TextDecoder()).decode(value, {\n                stream: true\n              }) : undefined;\n              const reportProgress = () => observer.next({\n                type: HttpEventType.DownloadProgress,\n                total: contentLength ? +contentLength : undefined,\n                loaded: receivedLength,\n                partialText\n              });\n              reqZone ? reqZone.run(reportProgress) : reportProgress();\n            }\n          }\n        });\n        if (canceled) {\n          observer.complete();\n          return;\n        }\n        const chunksAll = this.concatChunks(chunks, receivedLength);\n        try {\n          const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? '';\n          body = this.parseBody(request, chunksAll, contentType, status);\n        } catch (error) {\n          observer.error(new HttpErrorResponse({\n            error,\n            headers: new HttpHeaders(response.headers),\n            status: response.status,\n            statusText: response.statusText,\n            url: response.url || request.urlWithParams\n          }));\n          return;\n        }\n      }\n      if (status === 0) {\n        status = body ? HTTP_STATUS_CODE_OK : 0;\n      }\n      const ok = status >= 200 && status < 300;\n      const redirected = response.redirected;\n      const responseType = response.type;\n      if (ok) {\n        observer.next(new HttpResponse({\n          body,\n          headers,\n          status,\n          statusText,\n          url,\n          redirected,\n          responseType\n        }));\n        observer.complete();\n      } else {\n        observer.error(new HttpErrorResponse({\n          error: body,\n          headers,\n          status,\n          statusText,\n          url,\n          redirected,\n          responseType\n        }));\n      }\n    }\n    parseBody(request, binContent, contentType, status) {\n      switch (request.responseType) {\n        case 'json':\n          const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, '');\n          if (text === '') {\n            return null;\n          }\n          try {\n            return JSON.parse(text);\n          } catch (e) {\n            if (status < 200 || status >= 300) {\n              return text;\n            }\n            throw e;\n          }\n        case 'text':\n          return new TextDecoder().decode(binContent);\n        case 'blob':\n          return new Blob([binContent], {\n            type: contentType\n          });\n        case 'arraybuffer':\n          return binContent.buffer;\n      }\n    }\n    createRequestInit(req) {\n      const headers = {};\n      let credentials;\n      credentials = req.credentials;\n      if (req.withCredentials) {\n        (typeof ngDevMode === 'undefined' || ngDevMode) && warningOptionsMessage(req);\n        credentials = 'include';\n      }\n      req.headers.forEach((name, values) => headers[name] = values.join(','));\n      if (!req.headers.has(ACCEPT_HEADER)) {\n        headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;\n      }\n      if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n        const detectedType = req.detectContentTypeHeader();\n        if (detectedType !== null) {\n          headers[CONTENT_TYPE_HEADER] = detectedType;\n        }\n      }\n      return {\n        body: req.serializeBody(),\n        method: req.method,\n        headers,\n        credentials,\n        keepalive: req.keepalive,\n        cache: req.cache,\n        priority: req.priority,\n        mode: req.mode,\n        redirect: req.redirect,\n        referrer: req.referrer,\n        integrity: req.integrity,\n        referrerPolicy: req.referrerPolicy\n      };\n    }\n    concatChunks(chunks, totalLength) {\n      const chunksAll = new Uint8Array(totalLength);\n      let position = 0;\n      for (const chunk of chunks) {\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n      }\n      return chunksAll;\n    }\n    static ɵfac = function FetchBackend_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FetchBackend)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: FetchBackend,\n      factory: FetchBackend.ɵfac\n    });\n  }\n  return FetchBackend;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass FetchFactory {}\nfunction noop() {}\nfunction warningOptionsMessage(req) {\n  if (req.credentials && req.withCredentials) {\n    console.warn(_formatRuntimeError(2819, `Angular detected that a \\`HttpClient\\` request has both \\`withCredentials: true\\` and \\`credentials: '${req.credentials}'\\` options. The \\`withCredentials\\` option is overriding the explicit \\`credentials\\` setting to 'include'. Consider removing \\`withCredentials\\` and using \\`credentials: '${req.credentials}'\\` directly for clarity.`));\n  }\n}\nfunction silenceSuperfluousUnhandledPromiseRejection(promise) {\n  promise.then(noop, noop);\n}\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\nfunction validateXhrCompatibility(req) {\n  const unsupportedOptions = [{\n    property: 'keepalive',\n    errorCode: 2813\n  }, {\n    property: 'cache',\n    errorCode: 2814\n  }, {\n    property: 'priority',\n    errorCode: 2815\n  }, {\n    property: 'mode',\n    errorCode: 2816\n  }, {\n    property: 'redirect',\n    errorCode: 2817\n  }, {\n    property: 'credentials',\n    errorCode: 2818\n  }, {\n    property: 'integrity',\n    errorCode: 2820\n  }, {\n    property: 'referrer',\n    errorCode: 2821\n  }, {\n    property: 'referrerPolicy',\n    errorCode: 2823\n  }];\n  for (const {\n    property,\n    errorCode\n  } of unsupportedOptions) {\n    if (req[property]) {\n      console.warn(_formatRuntimeError(errorCode, `Angular detected that a \\`HttpClient\\` request with the \\`${property}\\` option was sent using XHR, which does not support it. To use the \\`${property}\\` option, enable Fetch API support by passing \\`withFetch()\\` as an argument to \\`provideHttpClient()\\`.`));\n    }\n  }\n}\nlet HttpXhrBackend = /*#__PURE__*/(() => {\n  class HttpXhrBackend {\n    xhrFactory;\n    tracingService = inject(_TracingService, {\n      optional: true\n    });\n    constructor(xhrFactory) {\n      this.xhrFactory = xhrFactory;\n    }\n    maybePropagateTrace(fn) {\n      return this.tracingService?.propagate ? this.tracingService.propagate(fn) : fn;\n    }\n    handle(req) {\n      if (req.method === 'JSONP') {\n        throw new _RuntimeError(-2800, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`);\n      }\n      ngDevMode && validateXhrCompatibility(req);\n      const xhrFactory = this.xhrFactory;\n      const source = typeof ngServerMode !== 'undefined' && ngServerMode && xhrFactory.ɵloadImpl ? from(xhrFactory.ɵloadImpl()) : of(null);\n      return source.pipe(switchMap(() => {\n        return new Observable(observer => {\n          const xhr = xhrFactory.build();\n          xhr.open(req.method, req.urlWithParams);\n          if (req.withCredentials) {\n            xhr.withCredentials = true;\n          }\n          req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n          if (!req.headers.has(ACCEPT_HEADER)) {\n            xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);\n          }\n          if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n            const detectedType = req.detectContentTypeHeader();\n            if (detectedType !== null) {\n              xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);\n            }\n          }\n          if (req.timeout) {\n            xhr.timeout = req.timeout;\n          }\n          if (req.responseType) {\n            const responseType = req.responseType.toLowerCase();\n            xhr.responseType = responseType !== 'json' ? responseType : 'text';\n          }\n          const reqBody = req.serializeBody();\n          let headerResponse = null;\n          const partialFromXhr = () => {\n            if (headerResponse !== null) {\n              return headerResponse;\n            }\n            const statusText = xhr.statusText || 'OK';\n            const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n            const url = xhr.responseURL || req.url;\n            headerResponse = new HttpHeaderResponse({\n              headers,\n              status: xhr.status,\n              statusText,\n              url\n            });\n            return headerResponse;\n          };\n          const onLoad = this.maybePropagateTrace(() => {\n            let {\n              headers,\n              status,\n              statusText,\n              url\n            } = partialFromXhr();\n            let body = null;\n            if (status !== HTTP_STATUS_CODE_NO_CONTENT) {\n              body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;\n            }\n            if (status === 0) {\n              status = !!body ? HTTP_STATUS_CODE_OK : 0;\n            }\n            let ok = status >= 200 && status < 300;\n            if (req.responseType === 'json' && typeof body === 'string') {\n              const originalBody = body;\n              body = body.replace(XSSI_PREFIX, '');\n              try {\n                body = body !== '' ? JSON.parse(body) : null;\n              } catch (error) {\n                body = originalBody;\n                if (ok) {\n                  ok = false;\n                  body = {\n                    error,\n                    text: body\n                  };\n                }\n              }\n            }\n            if (ok) {\n              observer.next(new HttpResponse({\n                body,\n                headers,\n                status,\n                statusText,\n                url: url || undefined\n              }));\n              observer.complete();\n            } else {\n              observer.error(new HttpErrorResponse({\n                error: body,\n                headers,\n                status,\n                statusText,\n                url: url || undefined\n              }));\n            }\n          });\n          const onError = this.maybePropagateTrace(error => {\n            const {\n              url\n            } = partialFromXhr();\n            const res = new HttpErrorResponse({\n              error,\n              status: xhr.status || 0,\n              statusText: xhr.statusText || 'Unknown Error',\n              url: url || undefined\n            });\n            observer.error(res);\n          });\n          let onTimeout = onError;\n          if (req.timeout) {\n            onTimeout = this.maybePropagateTrace(_ => {\n              const {\n                url\n              } = partialFromXhr();\n              const res = new HttpErrorResponse({\n                error: new DOMException('Request timed out', 'TimeoutError'),\n                status: xhr.status || 0,\n                statusText: xhr.statusText || 'Request timeout',\n                url: url || undefined\n              });\n              observer.error(res);\n            });\n          }\n          let sentHeaders = false;\n          const onDownProgress = this.maybePropagateTrace(event => {\n            if (!sentHeaders) {\n              observer.next(partialFromXhr());\n              sentHeaders = true;\n            }\n            let progressEvent = {\n              type: HttpEventType.DownloadProgress,\n              loaded: event.loaded\n            };\n            if (event.lengthComputable) {\n              progressEvent.total = event.total;\n            }\n            if (req.responseType === 'text' && !!xhr.responseText) {\n              progressEvent.partialText = xhr.responseText;\n            }\n            observer.next(progressEvent);\n          });\n          const onUpProgress = this.maybePropagateTrace(event => {\n            let progress = {\n              type: HttpEventType.UploadProgress,\n              loaded: event.loaded\n            };\n            if (event.lengthComputable) {\n              progress.total = event.total;\n            }\n            observer.next(progress);\n          });\n          xhr.addEventListener('load', onLoad);\n          xhr.addEventListener('error', onError);\n          xhr.addEventListener('timeout', onTimeout);\n          xhr.addEventListener('abort', onError);\n          if (req.reportProgress) {\n            xhr.addEventListener('progress', onDownProgress);\n            if (reqBody !== null && xhr.upload) {\n              xhr.upload.addEventListener('progress', onUpProgress);\n            }\n          }\n          xhr.send(reqBody);\n          observer.next({\n            type: HttpEventType.Sent\n          });\n          return () => {\n            xhr.removeEventListener('error', onError);\n            xhr.removeEventListener('abort', onError);\n            xhr.removeEventListener('load', onLoad);\n            xhr.removeEventListener('timeout', onTimeout);\n            if (req.reportProgress) {\n              xhr.removeEventListener('progress', onDownProgress);\n              if (reqBody !== null && xhr.upload) {\n                xhr.upload.removeEventListener('progress', onUpProgress);\n              }\n            }\n            if (xhr.readyState !== xhr.DONE) {\n              xhr.abort();\n            }\n          };\n        });\n      }));\n    }\n    static ɵfac = function HttpXhrBackend_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpXhrBackend)(i0.ɵɵinject(XhrFactory));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpXhrBackend,\n      factory: HttpXhrBackend.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HttpXhrBackend;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction interceptorChainEndFn(req, finalHandlerFn) {\n  return finalHandlerFn(req);\n}\nfunction adaptLegacyInterceptorToChain(chainTailFn, interceptor) {\n  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {\n    handle: downstreamRequest => chainTailFn(downstreamRequest, finalHandlerFn)\n  });\n}\nfunction chainedInterceptorFn(chainTailFn, interceptorFn, injector) {\n  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, downstreamRequest => chainTailFn(downstreamRequest, finalHandlerFn)));\n}\nconst HTTP_INTERCEPTORS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_INTERCEPTORS' : '');\nconst HTTP_INTERCEPTOR_FNS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '', {\n  factory: () => []\n});\nconst HTTP_ROOT_INTERCEPTOR_FNS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '');\nconst REQUESTS_CONTRIBUTE_TO_STABILITY = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'REQUESTS_CONTRIBUTE_TO_STABILITY' : '', {\n  factory: () => true\n});\nfunction legacyInterceptorFnFactory() {\n  let chain = null;\n  return (req, handler) => {\n    if (chain === null) {\n      const interceptors = inject(HTTP_INTERCEPTORS, {\n        optional: true\n      }) ?? [];\n      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);\n    }\n    const pendingTasks = inject(PendingTasks);\n    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    if (contributeToStability) {\n      const removeTask = pendingTasks.add();\n      return chain(req, handler).pipe(finalize(removeTask));\n    } else {\n      return chain(req, handler);\n    }\n  };\n}\nlet HttpBackend = /*#__PURE__*/(() => {\n  class HttpBackend {\n    static ɵfac = function HttpBackend_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpBackend)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpBackend,\n      factory: function HttpBackend_Factory(__ngFactoryType__) {\n        let __ngConditionalFactory__ = null;\n        if (__ngFactoryType__) {\n          __ngConditionalFactory__ = new (__ngFactoryType__ || HttpBackend)();\n        } else {\n          __ngConditionalFactory__ = i0.ɵɵinject(HttpXhrBackend);\n        }\n        return __ngConditionalFactory__;\n      },\n      providedIn: 'root'\n    });\n  }\n  return HttpBackend;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet fetchBackendWarningDisplayed = false;\nlet HttpInterceptorHandler = /*#__PURE__*/(() => {\n  class HttpInterceptorHandler {\n    backend;\n    injector;\n    chain = null;\n    pendingTasks = inject(PendingTasks);\n    contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    constructor(backend, injector) {\n      this.backend = backend;\n      this.injector = injector;\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !fetchBackendWarningDisplayed) {\n        const isTestingBackend = this.backend.isTestingBackend;\n        if (typeof ngServerMode !== 'undefined' && ngServerMode && !(this.backend instanceof FetchBackend) && !isTestingBackend) {\n          fetchBackendWarningDisplayed = true;\n          injector.get(_Console).warn(_formatRuntimeError(2801, 'Angular detected that `HttpClient` is not configured ' + \"to use `fetch` APIs. It's strongly recommended to \" + 'enable `fetch` for applications that use Server-Side Rendering ' + 'for better performance and compatibility. ' + 'To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` ' + 'call at the root of the application.'));\n        }\n      }\n    }\n    handle(initialRequest) {\n      if (this.chain === null) {\n        const dedupedInterceptorFns = Array.from(new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));\n        this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);\n      }\n      if (this.contributeToStability) {\n        const removeTask = this.pendingTasks.add();\n        return this.chain(initialRequest, downstreamRequest => this.backend.handle(downstreamRequest)).pipe(finalize(removeTask));\n      } else {\n        return this.chain(initialRequest, downstreamRequest => this.backend.handle(downstreamRequest));\n      }\n    }\n    static ɵfac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpInterceptorHandler)(i0.ɵɵinject(HttpBackend), i0.ɵɵinject(i0.EnvironmentInjector));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpInterceptorHandler,\n      factory: HttpInterceptorHandler.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HttpInterceptorHandler;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HttpHandler = /*#__PURE__*/(() => {\n  class HttpHandler {\n    static ɵfac = function HttpHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpHandler)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpHandler,\n      factory: function HttpHandler_Factory(__ngFactoryType__) {\n        let __ngConditionalFactory__ = null;\n        if (__ngFactoryType__) {\n          __ngConditionalFactory__ = new (__ngFactoryType__ || HttpHandler)();\n        } else {\n          __ngConditionalFactory__ = i0.ɵɵinject(HttpInterceptorHandler);\n        }\n        return __ngConditionalFactory__;\n      },\n      providedIn: 'root'\n    });\n  }\n  return HttpHandler;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction addBody(options, body) {\n  return {\n    body,\n    headers: options.headers,\n    context: options.context,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n    credentials: options.credentials,\n    transferCache: options.transferCache,\n    timeout: options.timeout,\n    keepalive: options.keepalive,\n    priority: options.priority,\n    cache: options.cache,\n    mode: options.mode,\n    redirect: options.redirect,\n    integrity: options.integrity,\n    referrer: options.referrer,\n    referrerPolicy: options.referrerPolicy\n  };\n}\nlet HttpClient = /*#__PURE__*/(() => {\n  class HttpClient {\n    handler;\n    constructor(handler) {\n      this.handler = handler;\n    }\n    request(first, url, options = {}) {\n      let req;\n      if (first instanceof HttpRequest) {\n        req = first;\n      } else {\n        let headers = undefined;\n        if (options.headers instanceof HttpHeaders) {\n          headers = options.headers;\n        } else {\n          headers = new HttpHeaders(options.headers);\n        }\n        let params = undefined;\n        if (!!options.params) {\n          if (options.params instanceof HttpParams) {\n            params = options.params;\n          } else {\n            params = new HttpParams({\n              fromObject: options.params\n            });\n          }\n        }\n        req = new HttpRequest(first, url, options.body !== undefined ? options.body : null, {\n          headers,\n          context: options.context,\n          params,\n          reportProgress: options.reportProgress,\n          responseType: options.responseType || 'json',\n          withCredentials: options.withCredentials,\n          transferCache: options.transferCache,\n          keepalive: options.keepalive,\n          priority: options.priority,\n          cache: options.cache,\n          mode: options.mode,\n          redirect: options.redirect,\n          credentials: options.credentials,\n          referrer: options.referrer,\n          referrerPolicy: options.referrerPolicy,\n          integrity: options.integrity,\n          timeout: options.timeout\n        });\n      }\n      const events$ = of(req).pipe(concatMap(req => this.handler.handle(req)));\n      if (first instanceof HttpRequest || options.observe === 'events') {\n        return events$;\n      }\n      const res$ = events$.pipe(filter(event => event instanceof HttpResponse));\n      switch (options.observe || 'body') {\n        case 'body':\n          switch (req.responseType) {\n            case 'arraybuffer':\n              return res$.pipe(map(res => {\n                if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                  throw new _RuntimeError(2806, ngDevMode && 'Response is not an ArrayBuffer.');\n                }\n                return res.body;\n              }));\n            case 'blob':\n              return res$.pipe(map(res => {\n                if (res.body !== null && !(res.body instanceof Blob)) {\n                  throw new _RuntimeError(2807, ngDevMode && 'Response is not a Blob.');\n                }\n                return res.body;\n              }));\n            case 'text':\n              return res$.pipe(map(res => {\n                if (res.body !== null && typeof res.body !== 'string') {\n                  throw new _RuntimeError(2808, ngDevMode && 'Response is not a string.');\n                }\n                return res.body;\n              }));\n            case 'json':\n            default:\n              return res$.pipe(map(res => res.body));\n          }\n        case 'response':\n          return res$;\n        default:\n          throw new _RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);\n      }\n    }\n    delete(url, options = {}) {\n      return this.request('DELETE', url, options);\n    }\n    get(url, options = {}) {\n      return this.request('GET', url, options);\n    }\n    head(url, options = {}) {\n      return this.request('HEAD', url, options);\n    }\n    jsonp(url, callbackParam) {\n      return this.request('JSONP', url, {\n        params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n        observe: 'body',\n        responseType: 'json'\n      });\n    }\n    options(url, options = {}) {\n      return this.request('OPTIONS', url, options);\n    }\n    patch(url, body, options = {}) {\n      return this.request('PATCH', url, addBody(options, body));\n    }\n    post(url, body, options = {}) {\n      return this.request('POST', url, addBody(options, body));\n    }\n    put(url, body, options = {}) {\n      return this.request('PUT', url, addBody(options, body));\n    }\n    static ɵfac = function HttpClient_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpClient)(i0.ɵɵinject(HttpHandler));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpClient,\n      factory: HttpClient.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HttpClient;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextRequestId = 0;\nlet foreignDocument;\nconst JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\nconst JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nconst JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\nconst JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';\nclass JsonpCallbackContext {}\nfunction jsonpCallbackContext() {\n  if (typeof window === 'object') {\n    return window;\n  }\n  return {};\n}\nlet JsonpClientBackend = /*#__PURE__*/(() => {\n  class JsonpClientBackend {\n    callbackMap;\n    document;\n    resolvedPromise = Promise.resolve();\n    constructor(callbackMap, document) {\n      this.callbackMap = callbackMap;\n      this.document = document;\n    }\n    nextCallback() {\n      return `ng_jsonp_callback_${nextRequestId++}`;\n    }\n    handle(req) {\n      if (req.method !== 'JSONP') {\n        throw new _RuntimeError(2810, ngDevMode && JSONP_ERR_WRONG_METHOD);\n      } else if (req.responseType !== 'json') {\n        throw new _RuntimeError(2811, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);\n      }\n      if (req.headers.keys().length > 0) {\n        throw new _RuntimeError(2812, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);\n      }\n      return new Observable(observer => {\n        const callback = this.nextCallback();\n        const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n        const node = this.document.createElement('script');\n        node.src = url;\n        let body = null;\n        let finished = false;\n        this.callbackMap[callback] = data => {\n          delete this.callbackMap[callback];\n          body = data;\n          finished = true;\n        };\n        const cleanup = () => {\n          node.removeEventListener('load', onLoad);\n          node.removeEventListener('error', onError);\n          node.remove();\n          delete this.callbackMap[callback];\n        };\n        const onLoad = () => {\n          this.resolvedPromise.then(() => {\n            cleanup();\n            if (!finished) {\n              observer.error(new HttpErrorResponse({\n                url,\n                status: 0,\n                statusText: 'JSONP Error',\n                error: new Error(JSONP_ERR_NO_CALLBACK)\n              }));\n              return;\n            }\n            observer.next(new HttpResponse({\n              body,\n              status: HTTP_STATUS_CODE_OK,\n              statusText: 'OK',\n              url\n            }));\n            observer.complete();\n          });\n        };\n        const onError = error => {\n          cleanup();\n          observer.error(new HttpErrorResponse({\n            error,\n            status: 0,\n            statusText: 'JSONP Error',\n            url\n          }));\n        };\n        node.addEventListener('load', onLoad);\n        node.addEventListener('error', onError);\n        this.document.body.appendChild(node);\n        observer.next({\n          type: HttpEventType.Sent\n        });\n        return () => {\n          if (!finished) {\n            this.removeListeners(node);\n          }\n          cleanup();\n        };\n      });\n    }\n    removeListeners(script) {\n      foreignDocument ??= this.document.implementation.createHTMLDocument();\n      foreignDocument.adoptNode(script);\n    }\n    static ɵfac = function JsonpClientBackend_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || JsonpClientBackend)(i0.ɵɵinject(JsonpCallbackContext), i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: JsonpClientBackend,\n      factory: JsonpClientBackend.ɵfac\n    });\n  }\n  return JsonpClientBackend;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction jsonpInterceptorFn(req, next) {\n  if (req.method === 'JSONP') {\n    return inject(JsonpClientBackend).handle(req);\n  }\n  return next(req);\n}\nlet JsonpInterceptor = /*#__PURE__*/(() => {\n  class JsonpInterceptor {\n    injector;\n    constructor(injector) {\n      this.injector = injector;\n    }\n    intercept(initialRequest, next) {\n      return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));\n    }\n    static ɵfac = function JsonpInterceptor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || JsonpInterceptor)(i0.ɵɵinject(i0.EnvironmentInjector));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: JsonpInterceptor,\n      factory: JsonpInterceptor.ɵfac\n    });\n  }\n  return JsonpInterceptor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst XSRF_ENABLED = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_ENABLED' : '', {\n  factory: () => true\n});\nconst XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';\nconst XSRF_COOKIE_NAME = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_COOKIE_NAME' : '', {\n  factory: () => XSRF_DEFAULT_COOKIE_NAME\n});\nconst XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';\nconst XSRF_HEADER_NAME = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'XSRF_HEADER_NAME' : '', {\n  factory: () => XSRF_DEFAULT_HEADER_NAME\n});\nlet HttpXsrfCookieExtractor = /*#__PURE__*/(() => {\n  class HttpXsrfCookieExtractor {\n    cookieName = inject(XSRF_COOKIE_NAME);\n    doc = inject(DOCUMENT);\n    lastCookieString = '';\n    lastToken = null;\n    parseCount = 0;\n    getToken() {\n      if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        return null;\n      }\n      const cookieString = this.doc.cookie || '';\n      if (cookieString !== this.lastCookieString) {\n        this.parseCount++;\n        this.lastToken = parseCookieValue(cookieString, this.cookieName);\n        this.lastCookieString = cookieString;\n      }\n      return this.lastToken;\n    }\n    static ɵfac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpXsrfCookieExtractor)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpXsrfCookieExtractor,\n      factory: HttpXsrfCookieExtractor.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HttpXsrfCookieExtractor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HttpXsrfTokenExtractor = /*#__PURE__*/(() => {\n  class HttpXsrfTokenExtractor {\n    static ɵfac = function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpXsrfTokenExtractor)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpXsrfTokenExtractor,\n      factory: function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {\n        let __ngConditionalFactory__ = null;\n        if (__ngFactoryType__) {\n          __ngConditionalFactory__ = new (__ngFactoryType__ || HttpXsrfTokenExtractor)();\n        } else {\n          __ngConditionalFactory__ = i0.ɵɵinject(HttpXsrfCookieExtractor);\n        }\n        return __ngConditionalFactory__;\n      },\n      providedIn: 'root'\n    });\n  }\n  return HttpXsrfTokenExtractor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction xsrfInterceptorFn(req, next) {\n  if (!inject(XSRF_ENABLED) || req.method === 'GET' || req.method === 'HEAD') {\n    return next(req);\n  }\n  try {\n    const locationHref = inject(PlatformLocation).href;\n    const {\n      origin: locationOrigin\n    } = new URL(locationHref);\n    const {\n      origin: requestOrigin\n    } = new URL(req.url, locationOrigin);\n    if (locationOrigin !== requestOrigin) {\n      return next(req);\n    }\n  } catch {\n    return next(req);\n  }\n  const token = inject(HttpXsrfTokenExtractor).getToken();\n  const headerName = inject(XSRF_HEADER_NAME);\n  if (token != null && !req.headers.has(headerName)) {\n    req = req.clone({\n      headers: req.headers.set(headerName, token)\n    });\n  }\n  return next(req);\n}\nlet HttpXsrfInterceptor = /*#__PURE__*/(() => {\n  class HttpXsrfInterceptor {\n    injector = inject(EnvironmentInjector);\n    intercept(initialRequest, next) {\n      return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));\n    }\n    static ɵfac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpXsrfInterceptor)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HttpXsrfInterceptor,\n      factory: HttpXsrfInterceptor.ɵfac\n    });\n  }\n  return HttpXsrfInterceptor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar HttpFeatureKind = /*#__PURE__*/function (HttpFeatureKind) {\n  HttpFeatureKind[HttpFeatureKind[\"Interceptors\"] = 0] = \"Interceptors\";\n  HttpFeatureKind[HttpFeatureKind[\"LegacyInterceptors\"] = 1] = \"LegacyInterceptors\";\n  HttpFeatureKind[HttpFeatureKind[\"CustomXsrfConfiguration\"] = 2] = \"CustomXsrfConfiguration\";\n  HttpFeatureKind[HttpFeatureKind[\"NoXsrfProtection\"] = 3] = \"NoXsrfProtection\";\n  HttpFeatureKind[HttpFeatureKind[\"JsonpSupport\"] = 4] = \"JsonpSupport\";\n  HttpFeatureKind[HttpFeatureKind[\"RequestsMadeViaParent\"] = 5] = \"RequestsMadeViaParent\";\n  HttpFeatureKind[HttpFeatureKind[\"Fetch\"] = 6] = \"Fetch\";\n  return HttpFeatureKind;\n}(HttpFeatureKind || {});\nfunction makeHttpFeature(kind, providers) {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers\n  };\n}\nfunction provideHttpClient(...features) {\n  if (ngDevMode) {\n    const featureKinds = new Set(features.map(f => f.ɵkind));\n    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {\n      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : '');\n    }\n  }\n  const providers = [HttpClient, HttpInterceptorHandler, {\n    provide: HttpHandler,\n    useExisting: HttpInterceptorHandler\n  }, {\n    provide: HttpBackend,\n    useFactory: () => {\n      return inject(FETCH_BACKEND, {\n        optional: true\n      }) ?? inject(HttpXhrBackend);\n    }\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useValue: xsrfInterceptorFn,\n    multi: true\n  }];\n  for (const feature of features) {\n    providers.push(...feature.ɵproviders);\n  }\n  return makeEnvironmentProviders(providers);\n}\nfunction withInterceptors(interceptorFns) {\n  return makeHttpFeature(HttpFeatureKind.Interceptors, interceptorFns.map(interceptorFn => {\n    return {\n      provide: HTTP_INTERCEPTOR_FNS,\n      useValue: interceptorFn,\n      multi: true\n    };\n  }));\n}\nconst LEGACY_INTERCEPTOR_FN = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'LEGACY_INTERCEPTOR_FN' : '');\nfunction withInterceptorsFromDi() {\n  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{\n    provide: LEGACY_INTERCEPTOR_FN,\n    useFactory: legacyInterceptorFnFactory\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useExisting: LEGACY_INTERCEPTOR_FN,\n    multi: true\n  }]);\n}\nfunction withXsrfConfiguration({\n  cookieName,\n  headerName\n}) {\n  const providers = [];\n  if (cookieName !== undefined) {\n    providers.push({\n      provide: XSRF_COOKIE_NAME,\n      useValue: cookieName\n    });\n  }\n  if (headerName !== undefined) {\n    providers.push({\n      provide: XSRF_HEADER_NAME,\n      useValue: headerName\n    });\n  }\n  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);\n}\nfunction withNoXsrfProtection() {\n  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{\n    provide: XSRF_ENABLED,\n    useValue: false\n  }]);\n}\nfunction withJsonpSupport() {\n  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {\n    provide: JsonpCallbackContext,\n    useFactory: jsonpCallbackContext\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useValue: jsonpInterceptorFn,\n    multi: true\n  }]);\n}\nfunction withRequestsMadeViaParent() {\n  return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [{\n    provide: HttpBackend,\n    useFactory: () => {\n      const handlerFromParent = inject(HttpHandler, {\n        skipSelf: true,\n        optional: true\n      });\n      if (ngDevMode && handlerFromParent === null) {\n        throw new Error('withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient');\n      }\n      return handlerFromParent;\n    }\n  }]);\n}\nfunction withFetch() {\n  return makeHttpFeature(HttpFeatureKind.Fetch, [FetchBackend, {\n    provide: FETCH_BACKEND,\n    useExisting: FetchBackend\n  }, {\n    provide: HttpBackend,\n    useExisting: FetchBackend\n  }]);\n}\nlet HttpClientXsrfModule = /*#__PURE__*/(() => {\n  class HttpClientXsrfModule {\n    static disable() {\n      return {\n        ngModule: HttpClientXsrfModule,\n        providers: [withNoXsrfProtection().ɵproviders]\n      };\n    }\n    static withOptions(options = {}) {\n      return {\n        ngModule: HttpClientXsrfModule,\n        providers: withXsrfConfiguration(options).ɵproviders\n      };\n    }\n    static ɵfac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpClientXsrfModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HttpClientXsrfModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [HttpXsrfInterceptor, {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: HttpXsrfInterceptor,\n        multi: true\n      }, {\n        provide: HttpXsrfTokenExtractor,\n        useClass: HttpXsrfCookieExtractor\n      }, withXsrfConfiguration({\n        cookieName: XSRF_DEFAULT_COOKIE_NAME,\n        headerName: XSRF_DEFAULT_HEADER_NAME\n      }).ɵproviders, {\n        provide: XSRF_ENABLED,\n        useValue: true\n      }]\n    });\n  }\n  return HttpClientXsrfModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HttpClientModule = /*#__PURE__*/(() => {\n  class HttpClientModule {\n    static ɵfac = function HttpClientModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpClientModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HttpClientModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [provideHttpClient(withInterceptorsFromDi())]\n    });\n  }\n  return HttpClientModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HttpClientJsonpModule = /*#__PURE__*/(() => {\n  class HttpClientJsonpModule {\n    static ɵfac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HttpClientJsonpModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HttpClientJsonpModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [withJsonpSupport().ɵproviders]\n    });\n  }\n  return HttpClientJsonpModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { FetchBackend, HTTP_INTERCEPTORS, HTTP_ROOT_INTERCEPTOR_FNS, HttpBackend, HttpClient, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpErrorResponse, HttpEventType, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpHeaders, HttpInterceptorHandler, HttpParams, HttpRequest, HttpResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, REQUESTS_CONTRIBUTE_TO_STABILITY, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { HttpHeaders, HttpParams, HttpRequest, HttpEventType, HttpErrorResponse, HttpClient, HTTP_ROOT_INTERCEPTOR_FNS, HttpResponse } from './_module-chunk.mjs';\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HttpInterceptorHandler as ɵHttpInterceptingHandler, REQUESTS_CONTRIBUTE_TO_STABILITY as ɵREQUESTS_CONTRIBUTE_TO_STABILITY } from './_module-chunk.mjs';\nimport { assertInInjectionContext, inject, Injector, ɵResourceImpl as _ResourceImpl, linkedSignal, computed, signal, ɵencapsulateResourceError as _encapsulateResourceError, ɵRuntimeError as _RuntimeError, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, TransferState, makeStateKey, ɵtruncateMiddle as _truncateMiddle, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport './_xhr-chunk.mjs';\nimport './_platform_location-chunk.mjs';\nconst httpResource = /*#__PURE__*/(() => {\n  const jsonFn = makeHttpResourceFn('json');\n  jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');\n  jsonFn.blob = makeHttpResourceFn('blob');\n  jsonFn.text = makeHttpResourceFn('text');\n  return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n  return function httpResource(request, options) {\n    if (ngDevMode && !options?.injector) {\n      assertInInjectionContext(httpResource);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.debugName, options?.parse, options?.equal);\n  };\n}\nfunction normalizeRequest(request, responseType) {\n  let unwrappedRequest = typeof request === 'function' ? request() : request;\n  if (unwrappedRequest === undefined) {\n    return undefined;\n  } else if (typeof unwrappedRequest === 'string') {\n    unwrappedRequest = {\n      url: unwrappedRequest\n    };\n  }\n  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);\n  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({\n    fromObject: unwrappedRequest.params\n  });\n  return new HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {\n    headers,\n    params,\n    reportProgress: unwrappedRequest.reportProgress,\n    withCredentials: unwrappedRequest.withCredentials,\n    keepalive: unwrappedRequest.keepalive,\n    cache: unwrappedRequest.cache,\n    priority: unwrappedRequest.priority,\n    mode: unwrappedRequest.mode,\n    redirect: unwrappedRequest.redirect,\n    responseType,\n    context: unwrappedRequest.context,\n    transferCache: unwrappedRequest.transferCache,\n    credentials: unwrappedRequest.credentials,\n    referrer: unwrappedRequest.referrer,\n    referrerPolicy: unwrappedRequest.referrerPolicy,\n    integrity: unwrappedRequest.integrity,\n    timeout: unwrappedRequest.timeout\n  });\n}\nclass HttpResourceImpl extends _ResourceImpl {\n  client;\n  _headers = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_headers\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _progress = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_progress\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _statusCode = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_statusCode\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  headers = /*#__PURE__*/computed(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{\n    debugName: \"headers\"\n  }] : []));\n  progress = /*#__PURE__*/this._progress.asReadonly();\n  statusCode = /*#__PURE__*/this._statusCode.asReadonly();\n  constructor(injector, request, defaultValue, debugName, parse, equal) {\n    super(request, ({\n      params: request,\n      abortSignal\n    }) => {\n      let sub;\n      const onAbort = () => sub.unsubscribe();\n      abortSignal.addEventListener('abort', onAbort);\n      const stream = signal({\n        value: undefined\n      }, ...(ngDevMode ? [{\n        debugName: \"stream\"\n      }] : []));\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      const send = value => {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      };\n      sub = this.client.request(request).subscribe({\n        next: event => {\n          switch (event.type) {\n            case HttpEventType.Response:\n              this._headers.set(event.headers);\n              this._statusCode.set(event.status);\n              try {\n                send({\n                  value: parse ? parse(event.body) : event.body\n                });\n              } catch (error) {\n                send({\n                  error: _encapsulateResourceError(error)\n                });\n              }\n              break;\n            case HttpEventType.DownloadProgress:\n              this._progress.set(event);\n              break;\n          }\n        },\n        error: error => {\n          if (error instanceof HttpErrorResponse) {\n            this._headers.set(error.headers);\n            this._statusCode.set(error.status);\n          }\n          send({\n            error\n          });\n          abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new _RuntimeError(991, ngDevMode && 'Resource completed before producing a value')\n            });\n          }\n          abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }, defaultValue, equal, debugName, injector);\n    this.client = injector.get(HttpClient);\n  }\n  set(value) {\n    super.set(value);\n    this._headers.set(undefined);\n    this._progress.set(undefined);\n    this._statusCode.set(undefined);\n  }\n}\nconst HTTP_TRANSFER_CACHE_ORIGIN_MAP = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst REQ_URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n  const {\n    isCacheActive,\n    ...globalOptions\n  } = inject(CACHE_OPTIONS);\n  const {\n    transferCache: requestOptions,\n    method: requestMethod\n  } = req;\n  if (!isCacheActive || requestOptions === false || requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions || requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod) || !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || globalOptions.filter?.(req) === false) {\n    return next(req);\n  }\n  const transferState = inject(TransferState);\n  const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {\n    optional: true\n  });\n  if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {\n    throw new _RuntimeError(2803, ngDevMode && 'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' + 'present in the client side code. Please ensure that this token is only provided in the ' + 'server code of the application.');\n  }\n  const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;\n  const storeKey = makeCacheKey(req, requestUrl);\n  const response = transferState.get(storeKey, null);\n  let headersToInclude = globalOptions.includeHeaders;\n  if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n    headersToInclude = requestOptions.includeHeaders;\n  }\n  if (response) {\n    const {\n      [BODY]: undecodedBody,\n      [RESPONSE_TYPE]: responseType,\n      [HEADERS]: httpHeaders,\n      [STATUS]: status,\n      [STATUS_TEXT]: statusText,\n      [REQ_URL]: url\n    } = response;\n    let body = undecodedBody;\n    switch (responseType) {\n      case 'arraybuffer':\n        body = new TextEncoder().encode(undecodedBody).buffer;\n        break;\n      case 'blob':\n        body = new Blob([undecodedBody]);\n        break;\n    }\n    let headers = new HttpHeaders(httpHeaders);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n    }\n    return of(new HttpResponse({\n      body,\n      headers,\n      status,\n      statusText,\n      url\n    }));\n  }\n  const event$ = next(req);\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return event$.pipe(tap(event => {\n      if (event instanceof HttpResponse) {\n        transferState.set(storeKey, {\n          [BODY]: event.body,\n          [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n          [STATUS]: event.status,\n          [STATUS_TEXT]: event.statusText,\n          [REQ_URL]: requestUrl,\n          [RESPONSE_TYPE]: req.responseType\n        });\n      }\n    }));\n  }\n  return event$;\n}\nfunction hasAuthHeaders(req) {\n  return req.headers.has('authorization') || req.headers.has('proxy-authorization');\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n  if (!includeHeaders) {\n    return {};\n  }\n  const headersMap = {};\n  for (const key of includeHeaders) {\n    const values = headers.getAll(key);\n    if (values !== null) {\n      headersMap[key] = values;\n    }\n  }\n  return headersMap;\n}\nfunction sortAndConcatParams(params) {\n  return [...params.keys()].sort().map(k => `${k}=${params.getAll(k)}`).join('&');\n}\nfunction makeCacheKey(request, mappedRequestUrl) {\n  const {\n    params,\n    method,\n    responseType\n  } = request;\n  const encodedParams = sortAndConcatParams(params);\n  let serializedBody = request.serializeBody();\n  if (serializedBody instanceof URLSearchParams) {\n    serializedBody = sortAndConcatParams(serializedBody);\n  } else if (typeof serializedBody !== 'string') {\n    serializedBody = '';\n  }\n  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');\n  const hash = generateHash(key);\n  return makeStateKey(hash);\n}\nfunction generateHash(value) {\n  let hash = 0;\n  for (const char of value) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  hash += 2147483647 + 1;\n  return hash.toString();\n}\nfunction withHttpTransferCache(cacheOptions) {\n  return [{\n    provide: CACHE_OPTIONS,\n    useFactory: () => {\n      _performanceMarkFeature('NgHttpTransferCache');\n      return {\n        isCacheActive: true,\n        ...cacheOptions\n      };\n    }\n  }, {\n    provide: HTTP_ROOT_INTERCEPTOR_FNS,\n    useValue: transferCacheInterceptorFn,\n    multi: true\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: () => {\n      const appRef = inject(ApplicationRef);\n      const cacheState = inject(CACHE_OPTIONS);\n      return () => {\n        appRef.whenStable().then(() => {\n          cacheState.isCacheActive = false;\n        });\n      };\n    }\n  }];\n}\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n  const warningProduced = new Set();\n  return new Proxy(headers, {\n    get(target, prop) {\n      const value = Reflect.get(target, prop);\n      const methods = new Set(['get', 'has', 'getAll']);\n      if (typeof value !== 'function' || !methods.has(prop)) {\n        return value;\n      }\n      return headerName => {\n        const key = (prop + ':' + headerName).toLowerCase();\n        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n          warningProduced.add(key);\n          const truncatedUrl = _truncateMiddle(url);\n          console.warn(_formatRuntimeError(-2802, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` + `was not transferred from the server to the client by the HttpTransferCache. ` + `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` + `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` + `on a request level by adding the \\`transferCache\\` parameter, or on an application ` + `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` + `\\`provideClientHydration()\\` call. `));\n        }\n        return value.apply(target, [headerName]);\n      };\n    }\n  });\n}\nfunction mapRequestOriginUrl(url, originMap) {\n  const origin = new URL(url, 'resolve://').origin;\n  const mappedOrigin = originMap[origin];\n  if (!mappedOrigin) {\n    return url;\n  }\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    verifyMappedOrigin(mappedOrigin);\n  }\n  return url.replace(origin, mappedOrigin);\n}\nfunction verifyMappedOrigin(url) {\n  if (new URL(url, 'resolve://').pathname !== '/') {\n    throw new _RuntimeError(2804, 'Angular detected a URL with a path segment in the value provided for the ' + `\\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\\` token: ${url}. The map should only contain origins ` + 'without any other segments.');\n  }\n}\nexport { HTTP_TRANSFER_CACHE_ORIGIN_MAP, HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpResponse, httpResource, HTTP_ROOT_INTERCEPTOR_FNS as ɵHTTP_ROOT_INTERCEPTOR_FNS, withHttpTransferCache as ɵwithHttpTransferCache };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nexport { BrowserModule, bootstrapApplication, createApplication, platformBrowser, provideProtractorTestingSupport, BrowserDomAdapter as ɵBrowserDomAdapter, BrowserGetTestability as ɵBrowserGetTestability, KeyEventsPlugin as ɵKeyEventsPlugin } from './_browser-chunk.mjs';\nimport { ɵgetDOM as _getDOM, DOCUMENT } from '@angular/common';\nexport { ɵgetDOM } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, ɵglobal as _global, ApplicationRef, InjectionToken, ɵConsole as _Console, Optional, Injector, NgModule, forwardRef, ɵRuntimeError as _RuntimeError, ɵXSS_SECURITY_URL as _XSS_SECURITY_URL, SecurityContext, ɵallowSanitizationBypassAndThrow as _allowSanitizationBypassAndThrow, ɵunwrapSafeValue as _unwrapSafeValue, ɵ_sanitizeUrl as __sanitizeUrl, ɵ_sanitizeHtml as __sanitizeHtml, ɵbypassSanitizationTrustHtml as _bypassSanitizationTrustHtml, ɵbypassSanitizationTrustStyle as _bypassSanitizationTrustStyle, ɵbypassSanitizationTrustScript as _bypassSanitizationTrustScript, ɵbypassSanitizationTrustUrl as _bypassSanitizationTrustUrl, ɵbypassSanitizationTrustResourceUrl as _bypassSanitizationTrustResourceUrl, ɵwithI18nSupport as _withI18nSupport, ɵwithEventReplay as _withEventReplay, ɵwithIncrementalHydration as _withIncrementalHydration, makeEnvironmentProviders, provideStabilityDebugging, ɵwithDomHydration as _withDomHydration, ENVIRONMENT_INITIALIZER, inject, ɵIS_ENABLED_BLOCKING_INITIAL_NAVIGATION as _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, ɵformatRuntimeError as _formatRuntimeError, Version } from '@angular/core';\nimport { EventManagerPlugin, EVENT_MANAGER_PLUGINS } from './_dom_renderer-chunk.mjs';\nexport { EventManager, REMOVE_STYLES_ON_COMPONENT_DESTROY, DomEventsPlugin as ɵDomEventsPlugin, DomRendererFactory2 as ɵDomRendererFactory2, SharedStylesHost as ɵSharedStylesHost } from './_dom_renderer-chunk.mjs';\nimport { ɵwithHttpTransferCache as _withHttpTransferCache } from '@angular/common/http';\nlet Meta = /*#__PURE__*/(() => {\n  class Meta {\n    _doc;\n    _dom;\n    constructor(_doc) {\n      this._doc = _doc;\n      this._dom = _getDOM();\n    }\n    addTag(tag, forceCreation = false) {\n      if (!tag) return null;\n      return this._getOrCreateElement(tag, forceCreation);\n    }\n    addTags(tags, forceCreation = false) {\n      if (!tags) return [];\n      return tags.reduce((result, tag) => {\n        if (tag) {\n          result.push(this._getOrCreateElement(tag, forceCreation));\n        }\n        return result;\n      }, []);\n    }\n    getTag(attrSelector) {\n      if (!attrSelector) return null;\n      return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n    }\n    getTags(attrSelector) {\n      if (!attrSelector) return [];\n      const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n      return list ? [].slice.call(list) : [];\n    }\n    updateTag(tag, selector) {\n      if (!tag) return null;\n      selector = selector || this._parseSelector(tag);\n      const meta = this.getTag(selector);\n      if (meta) {\n        return this._setMetaElementAttributes(tag, meta);\n      }\n      return this._getOrCreateElement(tag, true);\n    }\n    removeTag(attrSelector) {\n      this.removeTagElement(this.getTag(attrSelector));\n    }\n    removeTagElement(meta) {\n      if (meta) {\n        this._dom.remove(meta);\n      }\n    }\n    _getOrCreateElement(meta, forceCreation = false) {\n      if (!forceCreation) {\n        const selector = this._parseSelector(meta);\n        const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];\n        if (elem !== undefined) return elem;\n      }\n      const element = this._dom.createElement('meta');\n      this._setMetaElementAttributes(meta, element);\n      const head = this._doc.getElementsByTagName('head')[0];\n      head.appendChild(element);\n      return element;\n    }\n    _setMetaElementAttributes(tag, el) {\n      Object.keys(tag).forEach(prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));\n      return el;\n    }\n    _parseSelector(tag) {\n      const attr = tag.name ? 'name' : 'property';\n      return `${attr}=\"${tag[attr]}\"`;\n    }\n    _containsAttributes(tag, elem) {\n      return Object.keys(tag).every(key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);\n    }\n    _getMetaKeyMap(prop) {\n      return META_KEYS_MAP[prop] || prop;\n    }\n    static ɵfac = function Meta_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Meta)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Meta,\n      factory: Meta.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Meta;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst META_KEYS_MAP = {\n  httpEquiv: 'http-equiv'\n};\nlet Title = /*#__PURE__*/(() => {\n  class Title {\n    _doc;\n    constructor(_doc) {\n      this._doc = _doc;\n    }\n    getTitle() {\n      return this._doc.title;\n    }\n    setTitle(newTitle) {\n      this._doc.title = newTitle || '';\n    }\n    static ɵfac = function Title_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Title)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Title,\n      factory: Title.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Title;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction exportNgVar(name, value) {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    const ng = _global['ng'] = _global['ng'] || {};\n    ng[name] = value;\n  }\n}\nclass ChangeDetectionPerfRecord {\n  msPerTick;\n  numTicks;\n  constructor(msPerTick, numTicks) {\n    this.msPerTick = msPerTick;\n    this.numTicks = numTicks;\n  }\n}\nclass AngularProfiler {\n  appRef;\n  constructor(ref) {\n    this.appRef = ref.injector.get(ApplicationRef);\n  }\n  timeChangeDetection(config) {\n    const record = config && config['record'];\n    const profileName = 'Change Detection';\n    if (record && 'profile' in console && typeof console.profile === 'function') {\n      console.profile(profileName);\n    }\n    const start = performance.now();\n    let numTicks = 0;\n    while (numTicks < 5 || performance.now() - start < 500) {\n      this.appRef.tick();\n      numTicks++;\n    }\n    const end = performance.now();\n    if (record && 'profileEnd' in console && typeof console.profileEnd === 'function') {\n      console.profileEnd(profileName);\n    }\n    const msPerTick = (end - start) / numTicks;\n    console.log(`ran ${numTicks} change detection cycles`);\n    console.log(`${msPerTick.toFixed(2)} ms per check`);\n    return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n  }\n}\nconst PROFILER_GLOBAL_NAME = 'profiler';\nfunction enableDebugTools(ref) {\n  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n  return ref;\n}\nfunction disableDebugTools() {\n  exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\nclass By {\n  static all() {\n    return () => true;\n  }\n  static css(selector) {\n    return debugElement => {\n      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;\n    };\n  }\n  static directive(type) {\n    return debugNode => debugNode.providerTokens.indexOf(type) !== -1;\n  }\n}\nfunction elementMatches(n, selector) {\n  if (_getDOM().isElementNode(n)) {\n    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n  }\n  return false;\n}\nconst EVENT_NAMES = {\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  'press': true,\n  'pressup': true,\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  'tap': true,\n  'doubletap': true\n};\nconst HAMMER_GESTURE_CONFIG = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerGestureConfig' : '');\nconst HAMMER_LOADER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerLoader' : '');\nlet HammerGestureConfig = /*#__PURE__*/(() => {\n  class HammerGestureConfig {\n    events = [];\n    overrides = {};\n    options;\n    buildHammer(element) {\n      const mc = new Hammer(element, this.options);\n      mc.get('pinch').set({\n        enable: true\n      });\n      mc.get('rotate').set({\n        enable: true\n      });\n      for (const eventName in this.overrides) {\n        mc.get(eventName).set(this.overrides[eventName]);\n      }\n      return mc;\n    }\n    static ɵfac = function HammerGestureConfig_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerGestureConfig)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HammerGestureConfig,\n      factory: HammerGestureConfig.ɵfac\n    });\n  }\n  return HammerGestureConfig;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HammerGesturesPlugin = /*#__PURE__*/(() => {\n  class HammerGesturesPlugin extends EventManagerPlugin {\n    _config;\n    _injector;\n    loader;\n    _loaderPromise = null;\n    constructor(doc, _config, _injector, loader) {\n      super(doc);\n      this._config = _config;\n      this._injector = _injector;\n      this.loader = loader;\n    }\n    supports(eventName) {\n      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n        return false;\n      }\n      if (!window.Hammer && !this.loader) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          const _console = this._injector.get(_Console);\n          _console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);\n        }\n        return false;\n      }\n      return true;\n    }\n    addEventListener(element, eventName, handler) {\n      const zone = this.manager.getZone();\n      eventName = eventName.toLowerCase();\n      if (!window.Hammer && this.loader) {\n        this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());\n        let cancelRegistration = false;\n        let deregister = () => {\n          cancelRegistration = true;\n        };\n        zone.runOutsideAngular(() => this._loaderPromise.then(() => {\n          if (!window.Hammer) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              const _console = this._injector.get(_Console);\n              _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n            }\n            deregister = () => {};\n            return;\n          }\n          if (!cancelRegistration) {\n            deregister = this.addEventListener(element, eventName, handler);\n          }\n        }).catch(() => {\n          if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const _console = this._injector.get(_Console);\n            _console.warn(`The \"${eventName}\" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);\n          }\n          deregister = () => {};\n        }));\n        return () => {\n          deregister();\n        };\n      }\n      return zone.runOutsideAngular(() => {\n        const mc = this._config.buildHammer(element);\n        const callback = function (eventObj) {\n          zone.runGuarded(function () {\n            handler(eventObj);\n          });\n        };\n        mc.on(eventName, callback);\n        return () => {\n          mc.off(eventName, callback);\n          if (typeof mc.destroy === 'function') {\n            mc.destroy();\n          }\n        };\n      });\n    }\n    isCustomEvent(eventName) {\n      return this._config.events.indexOf(eventName) > -1;\n    }\n    static ɵfac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerGesturesPlugin)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(HAMMER_GESTURE_CONFIG), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(HAMMER_LOADER, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HammerGesturesPlugin,\n      factory: HammerGesturesPlugin.ɵfac\n    });\n  }\n  return HammerGesturesPlugin;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HammerModule = /*#__PURE__*/(() => {\n  class HammerModule {\n    static ɵfac = function HammerModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HammerModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [{\n        provide: EVENT_MANAGER_PLUGINS,\n        useClass: HammerGesturesPlugin,\n        multi: true,\n        deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]\n      }, {\n        provide: HAMMER_GESTURE_CONFIG,\n        useClass: HammerGestureConfig\n      }]\n    });\n  }\n  return HammerModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DomSanitizer = /*#__PURE__*/(() => {\n  class DomSanitizer {\n    static ɵfac = function DomSanitizer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomSanitizer)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomSanitizer,\n      factory: function DomSanitizer_Factory(__ngFactoryType__) {\n        let __ngConditionalFactory__ = null;\n        if (__ngFactoryType__) {\n          __ngConditionalFactory__ = new (__ngFactoryType__ || DomSanitizer)();\n        } else {\n          __ngConditionalFactory__ = i0.ɵɵinject(DomSanitizerImpl);\n        }\n        return __ngConditionalFactory__;\n      },\n      providedIn: 'root'\n    });\n  }\n  return DomSanitizer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DomSanitizerImpl = /*#__PURE__*/(() => {\n  class DomSanitizerImpl extends DomSanitizer {\n    _doc;\n    constructor(_doc) {\n      super();\n      this._doc = _doc;\n    }\n    sanitize(ctx, value) {\n      if (value == null) return null;\n      switch (ctx) {\n        case SecurityContext.NONE:\n          return value;\n        case SecurityContext.HTML:\n          if (_allowSanitizationBypassAndThrow(value, \"HTML\")) {\n            return _unwrapSafeValue(value);\n          }\n          return __sanitizeHtml(this._doc, String(value)).toString();\n        case SecurityContext.STYLE:\n          if (_allowSanitizationBypassAndThrow(value, \"Style\")) {\n            return _unwrapSafeValue(value);\n          }\n          return value;\n        case SecurityContext.SCRIPT:\n          if (_allowSanitizationBypassAndThrow(value, \"Script\")) {\n            return _unwrapSafeValue(value);\n          }\n          throw new _RuntimeError(5200, (typeof ngDevMode === 'undefined' || ngDevMode) && 'unsafe value used in a script context');\n        case SecurityContext.URL:\n          if (_allowSanitizationBypassAndThrow(value, \"URL\")) {\n            return _unwrapSafeValue(value);\n          }\n          return __sanitizeUrl(String(value));\n        case SecurityContext.RESOURCE_URL:\n          if (_allowSanitizationBypassAndThrow(value, \"ResourceURL\")) {\n            return _unwrapSafeValue(value);\n          }\n          throw new _RuntimeError(5201, (typeof ngDevMode === 'undefined' || ngDevMode) && `unsafe value used in a resource URL context (see ${_XSS_SECURITY_URL})`);\n        default:\n          throw new _RuntimeError(5202, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${_XSS_SECURITY_URL})`);\n      }\n    }\n    bypassSecurityTrustHtml(value) {\n      return _bypassSanitizationTrustHtml(value);\n    }\n    bypassSecurityTrustStyle(value) {\n      return _bypassSanitizationTrustStyle(value);\n    }\n    bypassSecurityTrustScript(value) {\n      return _bypassSanitizationTrustScript(value);\n    }\n    bypassSecurityTrustUrl(value) {\n      return _bypassSanitizationTrustUrl(value);\n    }\n    bypassSecurityTrustResourceUrl(value) {\n      return _bypassSanitizationTrustResourceUrl(value);\n    }\n    static ɵfac = function DomSanitizerImpl_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomSanitizerImpl)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomSanitizerImpl,\n      factory: DomSanitizerImpl.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DomSanitizerImpl;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar HydrationFeatureKind = /*#__PURE__*/function (HydrationFeatureKind) {\n  HydrationFeatureKind[HydrationFeatureKind[\"NoHttpTransferCache\"] = 0] = \"NoHttpTransferCache\";\n  HydrationFeatureKind[HydrationFeatureKind[\"HttpTransferCacheOptions\"] = 1] = \"HttpTransferCacheOptions\";\n  HydrationFeatureKind[HydrationFeatureKind[\"I18nSupport\"] = 2] = \"I18nSupport\";\n  HydrationFeatureKind[HydrationFeatureKind[\"EventReplay\"] = 3] = \"EventReplay\";\n  HydrationFeatureKind[HydrationFeatureKind[\"IncrementalHydration\"] = 4] = \"IncrementalHydration\";\n  return HydrationFeatureKind;\n}(HydrationFeatureKind || {});\nfunction hydrationFeature(ɵkind, ɵproviders = [], ɵoptions = {}) {\n  return {\n    ɵkind,\n    ɵproviders\n  };\n}\nfunction withNoHttpTransferCache() {\n  return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);\n}\nfunction withHttpTransferCacheOptions(options) {\n  return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, _withHttpTransferCache(options));\n}\nfunction withI18nSupport() {\n  return hydrationFeature(HydrationFeatureKind.I18nSupport, _withI18nSupport());\n}\nfunction withEventReplay() {\n  return hydrationFeature(HydrationFeatureKind.EventReplay, _withEventReplay());\n}\nfunction withIncrementalHydration() {\n  return hydrationFeature(HydrationFeatureKind.IncrementalHydration, _withIncrementalHydration());\n}\nfunction provideEnabledBlockingInitialNavigationDetector() {\n  return [{\n    provide: ENVIRONMENT_INITIALIZER,\n    useValue: () => {\n      const isEnabledBlockingInitialNavigation = inject(_IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, {\n        optional: true\n      });\n      if (isEnabledBlockingInitialNavigation) {\n        const console = inject(_Console);\n        const message = _formatRuntimeError(5001, 'Configuration error: found both hydration and enabledBlocking initial navigation ' + 'in the same application, which is a contradiction.');\n        console.warn(message);\n      }\n    },\n    multi: true\n  }];\n}\nfunction provideClientHydration(...features) {\n  const providers = [];\n  const featuresKind = new Set();\n  for (const {\n    ɵproviders,\n    ɵkind\n  } of features) {\n    featuresKind.add(ɵkind);\n    if (ɵproviders.length) {\n      providers.push(ɵproviders);\n    }\n  }\n  const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) && hasHttpTransferCacheOptions) {\n    throw new _RuntimeError(5001, 'Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.');\n  }\n  return makeEnvironmentProviders([typeof ngDevMode !== 'undefined' && ngDevMode ? provideEnabledBlockingInitialNavigationDetector() : [], typeof ngDevMode !== 'undefined' && ngDevMode ? provideStabilityDebugging() : [], _withDomHydration(), featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions ? [] : _withHttpTransferCache({}), providers]);\n}\nconst VERSION = /* @__PURE__ */new Version('21.1.2');\nexport { By, DomSanitizer, EVENT_MANAGER_PLUGINS, EventManagerPlugin, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerModule, HydrationFeatureKind, Meta, Title, VERSION, disableDebugTools, enableDebugTools, provideClientHydration, withEventReplay, withHttpTransferCacheOptions, withI18nSupport, withIncrementalHydration, withNoHttpTransferCache, DomSanitizerImpl as ɵDomSanitizerImpl, HammerGesturesPlugin as ɵHammerGesturesPlugin };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ɵisPromise as _isPromise, computed, ɵRuntimeError as _RuntimeError, Injectable, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Directive, Input, Output, reflectComponentType, Component, runInInjectionContext, ɵisInjectable as _isInjectable, ɵisNgModule as _isNgModule, isStandalone, createEnvironmentInjector, Compiler, NgModuleFactory, ɵresolveComponentResources as _resolveComponentResources, afterNextRender, signal, EnvironmentInjector, DestroyRef, untracked, ɵConsole as _Console, ɵPendingTasksInternal as _PendingTasksInternal, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, Observable, concat, defer, pipe, EMPTY, throwError, Subject, Subscription } from 'rxjs';\nimport { first, map, switchMap, take, startWith, filter, takeUntil, mergeMap, concatMap, tap, takeLast, catchError, finalize } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\nconst PRIMARY_OUTLET = 'primary';\nconst RouteTitleKey = /* @__PURE__ */Symbol('RouteTitle');\nclass ParamsAsMap {\n  params;\n  constructor(params) {\n    this.params = params || {};\n  }\n  has(name) {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n  get(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n    return null;\n  }\n  getAll(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n    return [];\n  }\n  get keys() {\n    return Object.keys(this.params);\n  }\n}\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\nfunction matchParts(routeParts, urlSegments, posParams) {\n  for (let i = 0; i < routeParts.length; i++) {\n    const part = routeParts[i];\n    const segment = urlSegments[i];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  const parts = route.path.split('/');\n  const wildcardIndex = parts.indexOf('**');\n  if (wildcardIndex === -1) {\n    if (parts.length > segments.length) {\n      return null;\n    }\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n      return null;\n    }\n    const posParams = {};\n    const consumed = segments.slice(0, parts.length);\n    if (!matchParts(parts, consumed, posParams)) {\n      return null;\n    }\n    return {\n      consumed,\n      posParams\n    };\n  }\n  if (wildcardIndex !== parts.lastIndexOf('**')) {\n    return null;\n  }\n  const pre = parts.slice(0, wildcardIndex);\n  const post = parts.slice(wildcardIndex + 1);\n  if (pre.length + post.length > segments.length) {\n    return null;\n  }\n  if (route.pathMatch === 'full' && segmentGroup.hasChildren() && route.path !== '**') {\n    return null;\n  }\n  const posParams = {};\n  if (!matchParts(pre, segments.slice(0, pre.length), posParams)) {\n    return null;\n  }\n  if (!matchParts(post, segments.slice(segments.length - post.length), posParams)) {\n    return null;\n  }\n  return {\n    consumed: segments,\n    posParams\n  };\n}\nfunction firstValueFrom(source) {\n  return new Promise((resolve, reject) => {\n    source.pipe(first()).subscribe({\n      next: value => resolve(value),\n      error: err => reject(err)\n    });\n  });\n}\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction shallowEqual(a, b) {\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getDataKeys(obj) {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\nfunction equalArraysOrString(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\nfunction last(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n  if (_isPromise(value)) {\n    return from(Promise.resolve(value));\n  }\n  return of(value);\n}\nfunction wrapIntoPromise(value) {\n  if (isObservable(value)) {\n    return firstValueFrom(value);\n  }\n  return Promise.resolve(value);\n}\nconst pathCompareMap = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup\n};\nconst paramCompareMap = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true\n};\nfunction isActive(url, router, matchOptions) {\n  const urlTree = url instanceof UrlTree ? url : router.parseUrl(url);\n  return computed(() => containsTree(router.lastSuccessfulNavigation()?.finalUrl ?? new UrlTree(), urlTree, matchOptions));\n}\nfunction containsTree(container, containee, options) {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\nfunction equalParams(container, containee) {\n  return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;\n  }\n  return true;\n}\nfunction containsParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\nclass UrlTree {\n  root;\n  queryParams;\n  fragment;\n  _queryParamMap;\n  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new _RuntimeError(4015, 'The root `UrlSegmentGroup` should not contain `segments`. ' + 'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n      }\n    }\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\nclass UrlSegmentGroup {\n  segments;\n  children;\n  parent = null;\n  constructor(segments, children) {\n    this.segments = segments;\n    this.children = children;\n    Object.values(children).forEach(v => v.parent = this);\n  }\n  hasChildren() {\n    return this.numberOfChildren > 0;\n  }\n  get numberOfChildren() {\n    return Object.keys(this.children).length;\n  }\n  toString() {\n    return serializePaths(this);\n  }\n}\nclass UrlSegment {\n  path;\n  parameters;\n  _parameterMap;\n  constructor(path, parameters) {\n    this.path = path;\n    this.parameters = parameters;\n  }\n  get parameterMap() {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n  toString() {\n    return serializePath(this);\n  }\n}\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n  let res = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\nlet UrlSerializer = /*#__PURE__*/(() => {\n  class UrlSerializer {\n    static ɵfac = function UrlSerializer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UrlSerializer)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: UrlSerializer,\n      factory: () => (() => new DefaultUrlSerializer())(),\n      providedIn: 'root'\n    });\n  }\n  return UrlSerializer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultUrlSerializer {\n  parse(url) {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n  serialize(tree) {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n    return `${segment}${query}${fragment}`;\n  }\n}\nconst DEFAULT_SERIALIZER = /*#__PURE__*/new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    const children = [];\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v, k) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\nfunction serializePath(path) {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join('');\n}\nfunction serializeQueryParams(params) {\n  const strParams = Object.entries(params).map(([name, value]) => {\n    return Array.isArray(value) ? value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n  }).filter(s => s);\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\nfunction matchQueryParams(str) {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\nfunction matchUrlQueryParamValue(str) {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\nclass UrlParser {\n  url;\n  remaining;\n  constructor(url) {\n    this.url = url;\n    this.remaining = url;\n  }\n  parseRootSegment() {\n    this.consumeOptional('/');\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n  parseQueryParams() {\n    const params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n  parseFragment() {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n  parseChildren() {\n    if (this.remaining === '') {\n      return {};\n    }\n    this.consumeOptional('/');\n    const segments = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n    let children = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n    let res = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n    return res;\n  }\n  parseSegment() {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new _RuntimeError(4009, (typeof ngDevMode === 'undefined' || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n  parseMatrixParams() {\n    const params = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n  parseParam(params) {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    params[decode(key)] = decode(value);\n  }\n  parseQueryParam(params) {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n    if (params.hasOwnProperty(decodedKey)) {\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      params[decodedKey] = decodedVal;\n    }\n  }\n  parseParens(allowPrimary) {\n    const segments = {};\n    this.capture('(');\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n      const next = this.remaining[path.length];\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new _RuntimeError(4010, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n      }\n      let outletName;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n      const children = this.parseChildren();\n      segments[outletName ?? PRIMARY_OUTLET] = Object.keys(children).length === 1 && children[PRIMARY_OUTLET] ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n    return segments;\n  }\n  peekStartsWith(str) {\n    return this.remaining.startsWith(str);\n  }\n  consumeOptional(str) {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n  capture(str) {\n    if (!this.consumeOptional(str)) {\n      throw new _RuntimeError(4011, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n    }\n  }\n}\nfunction createRoot(rootCandidate) {\n  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {\n    [PRIMARY_OUTLET]: rootCandidate\n  }) : rootCandidate;\n}\nfunction squashSegmentGroup(segmentGroup) {\n  const newChildren = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n  return s;\n}\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null, urlSerializer = new DefaultUrlSerializer()) {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment, urlSerializer);\n}\nfunction createSegmentGroupFromRoute(route) {\n  let targetGroup;\n  function createSegmentGroupFromRouteRecursive(currentRoute) {\n    const childOutlets = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n  return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment, urlSerializer) {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment, urlSerializer);\n  }\n  const nav = computeNavigation(commands);\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment, urlSerializer);\n  }\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer);\n}\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\nfunction isCommandWithOutlets(command) {\n  return typeof command === 'object' && command != null && command.outlets;\n}\nfunction normalizeQueryParams(k, v, urlSerializer) {\n  k ||= 'ɵ';\n  const tree = new UrlTree();\n  tree.queryParams = {\n    [k]: v\n  };\n  return urlSerializer.parse(urlSerializer.serialize(tree)).queryParams[k];\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer) {\n  const qp = {};\n  for (const [key, value] of Object.entries(queryParams ?? {})) {\n    qp[key] = Array.isArray(value) ? value.map(v => normalizeQueryParams(key, v, urlSerializer)) : normalizeQueryParams(key, value, urlSerializer);\n  }\n  let rootCandidate;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\nfunction replaceSegment(current, oldSegment, newSegment) {\n  const children = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\nclass Navigation {\n  isAbsolute;\n  numberOfDoubleDots;\n  commands;\n  constructor(isAbsolute, numberOfDoubleDots, commands) {\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new _RuntimeError(4003, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Root segment cannot have matrix parameters');\n    }\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new _RuntimeError(4004, (typeof ngDevMode === 'undefined' || ngDevMode) && '{outlets:{}} has to be the last command');\n    }\n  }\n  toRoot() {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n  const res = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {\n          outlets\n        }];\n      }\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') ;else if (partIndex == 0 && urlPart === '') {\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n    return [...res, cmd];\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nclass Position {\n  segmentGroup;\n  processChildren;\n  index;\n  constructor(segmentGroup, processChildren, index) {\n    this.segmentGroup = segmentGroup;\n    this.processChildren = processChildren;\n    this.index = index;\n  }\n}\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n  if (!target) {\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent;\n    if (!g) {\n      throw new _RuntimeError(4005, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n  return {\n    [PRIMARY_OUTLET]: commands\n  };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children = {};\n    if (Object.keys(outlets).some(o => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n  const noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n  const children = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\nfunction stringify(params) {\n  const res = {};\n  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);\n  return res;\n}\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\nconst IMPERATIVE_NAVIGATION = 'imperative';\nvar EventType = /*#__PURE__*/function (EventType) {\n  EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\n  EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n  EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n  EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\n  EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n  EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\n  EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n  EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n  EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n  EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n  EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n  EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n  EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n  EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\n  EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n  EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\n  EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n  return EventType;\n}(EventType || {});\nclass RouterEvent {\n  id;\n  url;\n  constructor(id, url) {\n    this.id = id;\n    this.url = url;\n  }\n}\nclass NavigationStart extends RouterEvent {\n  type = EventType.NavigationStart;\n  navigationTrigger;\n  restoredState;\n  constructor(id, url, navigationTrigger = 'imperative', restoredState = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n  toString() {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\nclass NavigationEnd extends RouterEvent {\n  urlAfterRedirects;\n  type = EventType.NavigationEnd;\n  constructor(id, url, urlAfterRedirects) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n  }\n  toString() {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\nvar NavigationCancellationCode = /*#__PURE__*/function (NavigationCancellationCode) {\n  NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\n  NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n  NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n  NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\n  NavigationCancellationCode[NavigationCancellationCode[\"Aborted\"] = 4] = \"Aborted\";\n  return NavigationCancellationCode;\n}(NavigationCancellationCode || {});\nvar NavigationSkippedCode = /*#__PURE__*/function (NavigationSkippedCode) {\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n  return NavigationSkippedCode;\n}(NavigationSkippedCode || {});\nclass NavigationCancel extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationCancel;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n  toString() {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\nfunction isRedirectingEvent(event) {\n  return event instanceof NavigationCancel && (event.code === NavigationCancellationCode.Redirect || event.code === NavigationCancellationCode.SupersededByNewNavigation);\n}\nclass NavigationSkipped extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationSkipped;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n}\nclass NavigationError extends RouterEvent {\n  error;\n  target;\n  type = EventType.NavigationError;\n  constructor(id, url, error, target) {\n    super(id, url);\n    this.error = error;\n    this.target = target;\n  }\n  toString() {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\nclass RoutesRecognized extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.RoutesRecognized;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass GuardsCheckStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.GuardsCheckStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass GuardsCheckEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  shouldActivate;\n  type = EventType.GuardsCheckEnd;\n  constructor(id, url, urlAfterRedirects, state, shouldActivate) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n    this.shouldActivate = shouldActivate;\n  }\n  toString() {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\nclass ResolveStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass ResolveEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveEnd;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass RouteConfigLoadStart {\n  route;\n  type = EventType.RouteConfigLoadStart;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\nclass RouteConfigLoadEnd {\n  route;\n  type = EventType.RouteConfigLoadEnd;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\nclass ChildActivationStart {\n  snapshot;\n  type = EventType.ChildActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\nclass ChildActivationEnd {\n  snapshot;\n  type = EventType.ChildActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\nclass ActivationStart {\n  snapshot;\n  type = EventType.ActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\nclass ActivationEnd {\n  snapshot;\n  type = EventType.ActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\nclass Scroll {\n  routerEvent;\n  position;\n  anchor;\n  scrollBehavior;\n  type = EventType.Scroll;\n  constructor(routerEvent, position, anchor, scrollBehavior) {\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n    this.scrollBehavior = scrollBehavior;\n  }\n  toString() {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\nclass BeforeActivateRoutes {}\nclass RedirectRequest {\n  url;\n  navigationBehaviorOptions;\n  constructor(url, navigationBehaviorOptions) {\n    this.url = url;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nfunction isPublicRouterEvent(e) {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nfunction stringifyEvent(routerEvent) {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\nclass OutletContext {\n  rootInjector;\n  outlet = null;\n  route = null;\n  children;\n  attachRef = null;\n  get injector() {\n    return this.route?.snapshot._environmentInjector ?? this.rootInjector;\n  }\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\nlet ChildrenOutletContexts = /*#__PURE__*/(() => {\n  class ChildrenOutletContexts {\n    rootInjector;\n    contexts = new Map();\n    constructor(rootInjector) {\n      this.rootInjector = rootInjector;\n    }\n    onChildOutletCreated(childName, outlet) {\n      const context = this.getOrCreateContext(childName);\n      context.outlet = outlet;\n      this.contexts.set(childName, context);\n    }\n    onChildOutletDestroyed(childName) {\n      const context = this.getContext(childName);\n      if (context) {\n        context.outlet = null;\n        context.attachRef = null;\n      }\n    }\n    onOutletDeactivated() {\n      const contexts = this.contexts;\n      this.contexts = new Map();\n      return contexts;\n    }\n    onOutletReAttached(contexts) {\n      this.contexts = contexts;\n    }\n    getOrCreateContext(childName) {\n      let context = this.getContext(childName);\n      if (!context) {\n        context = new OutletContext(this.rootInjector);\n        this.contexts.set(childName, context);\n      }\n      return context;\n    }\n    getContext(childName) {\n      return this.contexts.get(childName) || null;\n    }\n    static ɵfac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ChildrenOutletContexts)(i0.ɵɵinject(i0.EnvironmentInjector));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ChildrenOutletContexts,\n      factory: ChildrenOutletContexts.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ChildrenOutletContexts;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass Tree {\n  _root;\n  constructor(root) {\n    this._root = root;\n  }\n  get root() {\n    return this._root.value;\n  }\n  parent(t) {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n  children(t) {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n  firstChild(t) {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n  siblings(t) {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n  pathFromRoot(t) {\n    return findPath(t, this._root).map(s => s.value);\n  }\n}\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n  return null;\n}\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n  return [];\n}\nclass TreeNode {\n  value;\n  children;\n  constructor(value, children) {\n    this.value = value;\n    this.children = children;\n  }\n  toString() {\n    return `TreeNode(${this.value})`;\n  }\n}\nfunction nodeChildrenAsMap(node) {\n  const map = {};\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n  return map;\n}\nclass RouterState extends Tree {\n  snapshot;\n  constructor(root, snapshot) {\n    super(root);\n    this.snapshot = snapshot;\n    setRouterState(this, root);\n  }\n  toString() {\n    return this.snapshot.toString();\n  }\n}\nfunction createEmptyState(rootComponent, injector) {\n  const snapshot = createEmptyStateSnapshot(rootComponent, injector);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject('');\n  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent, injector) {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {}, injector);\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\nclass ActivatedRoute {\n  urlSubject;\n  paramsSubject;\n  queryParamsSubject;\n  fragmentSubject;\n  dataSubject;\n  outlet;\n  component;\n  snapshot;\n  _futureSnapshot;\n  _routerState;\n  _paramMap;\n  _queryParamMap;\n  title;\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {\n    this.urlSubject = urlSubject;\n    this.paramsSubject = paramsSubject;\n    this.queryParamsSubject = queryParamsSubject;\n    this.fragmentSubject = fragmentSubject;\n    this.dataSubject = dataSubject;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map(d => d[RouteTitleKey])) ?? of(undefined);\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n  get routeConfig() {\n    return this._futureSnapshot.routeConfig;\n  }\n  get root() {\n    return this._routerState.root;\n  }\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  get children() {\n    return this._routerState.children(this);\n  }\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= this.params.pipe(map(p => convertToParamMap(p)));\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= this.queryParams.pipe(map(p => convertToParamMap(p)));\n    return this._queryParamMap;\n  }\n  toString() {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\n  let inherited;\n  const {\n    routeConfig\n  } = route;\n  if (parent !== null && (paramsInheritanceStrategy === 'always' || routeConfig?.path === '' || !parent.component && !parent.routeConfig?.loadComponent)) {\n    inherited = {\n      params: {\n        ...parent.params,\n        ...route.params\n      },\n      data: {\n        ...parent.data,\n        ...route.data\n      },\n      resolve: {\n        ...route.data,\n        ...parent.data,\n        ...routeConfig?.data,\n        ...route._resolvedData\n      }\n    };\n  } else {\n    inherited = {\n      params: {\n        ...route.params\n      },\n      data: {\n        ...route.data\n      },\n      resolve: {\n        ...route.data,\n        ...(route._resolvedData ?? {})\n      }\n    };\n  }\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\nclass ActivatedRouteSnapshot {\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  outlet;\n  component;\n  routeConfig;\n  _resolve;\n  _resolvedData;\n  _routerState;\n  _paramMap;\n  _queryParamMap;\n  _environmentInjector;\n  get title() {\n    return this.data?.[RouteTitleKey];\n  }\n  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve, environmentInjector) {\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n    this._environmentInjector = environmentInjector;\n  }\n  get root() {\n    return this._routerState.root;\n  }\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  get children() {\n    return this._routerState.children(this);\n  }\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\nclass RouterStateSnapshot extends Tree {\n  url;\n  constructor(url, root) {\n    super(root);\n    this.url = url;\n    setRouterState(this, root);\n  }\n  toString() {\n    return serializeNode(this._root);\n  }\n}\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\n}\nfunction hasStaticTitle(config) {\n  return typeof config.title === 'string' || config.title === null;\n}\nconst ROUTER_OUTLET_DATA = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RouterOutlet data' : '');\nlet RouterOutlet = /*#__PURE__*/(() => {\n  class RouterOutlet {\n    activated = null;\n    get activatedComponentRef() {\n      return this.activated;\n    }\n    _activatedRoute = null;\n    name = PRIMARY_OUTLET;\n    activateEvents = new EventEmitter();\n    deactivateEvents = new EventEmitter();\n    attachEvents = new EventEmitter();\n    detachEvents = new EventEmitter();\n    routerOutletData = input(...(ngDevMode ? [undefined, {\n      debugName: \"routerOutletData\"\n    }] : []));\n    parentContexts = inject(ChildrenOutletContexts);\n    location = inject(ViewContainerRef);\n    changeDetector = inject(ChangeDetectorRef);\n    inputBinder = inject(INPUT_BINDER, {\n      optional: true\n    });\n    supportsBindingToComponentInputs = true;\n    ngOnChanges(changes) {\n      if (changes['name']) {\n        const {\n          firstChange,\n          previousValue\n        } = changes['name'];\n        if (firstChange) {\n          return;\n        }\n        if (this.isTrackedInParentContexts(previousValue)) {\n          this.deactivate();\n          this.parentContexts.onChildOutletDestroyed(previousValue);\n        }\n        this.initializeOutletWithName();\n      }\n    }\n    ngOnDestroy() {\n      if (this.isTrackedInParentContexts(this.name)) {\n        this.parentContexts.onChildOutletDestroyed(this.name);\n      }\n      this.inputBinder?.unsubscribeFromRouteData(this);\n    }\n    isTrackedInParentContexts(outletName) {\n      return this.parentContexts.getContext(outletName)?.outlet === this;\n    }\n    ngOnInit() {\n      this.initializeOutletWithName();\n    }\n    initializeOutletWithName() {\n      this.parentContexts.onChildOutletCreated(this.name, this);\n      if (this.activated) {\n        return;\n      }\n      const context = this.parentContexts.getContext(this.name);\n      if (context?.route) {\n        if (context.attachRef) {\n          this.attach(context.attachRef, context.route);\n        } else {\n          this.activateWith(context.route, context.injector);\n        }\n      }\n    }\n    get isActivated() {\n      return !!this.activated;\n    }\n    get component() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      return this.activated.instance;\n    }\n    get activatedRoute() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      return this._activatedRoute;\n    }\n    get activatedRouteData() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n      return {};\n    }\n    detach() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      this.location.detach();\n      const cmp = this.activated;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.detachEvents.emit(cmp.instance);\n      return cmp;\n    }\n    attach(ref, activatedRoute) {\n      this.activated = ref;\n      this._activatedRoute = activatedRoute;\n      this.location.insert(ref.hostView);\n      this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n      this.attachEvents.emit(ref.instance);\n    }\n    deactivate() {\n      if (this.activated) {\n        const c = this.component;\n        this.activated.destroy();\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n      if (this.isActivated) {\n        throw new _RuntimeError(4013, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Cannot activate an already activated outlet');\n      }\n      this._activatedRoute = activatedRoute;\n      const location = this.location;\n      const snapshot = activatedRoute.snapshot;\n      const component = snapshot.component;\n      const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n      const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\n      this.activated = location.createComponent(component, {\n        index: location.length,\n        injector,\n        environmentInjector: environmentInjector\n      });\n      this.changeDetector.markForCheck();\n      this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n      this.activateEvents.emit(this.activated.instance);\n    }\n    static ɵfac = function RouterOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterOutlet,\n      selectors: [[\"router-outlet\"]],\n      inputs: {\n        name: \"name\",\n        routerOutletData: [1, \"routerOutletData\"]\n      },\n      outputs: {\n        activateEvents: \"activate\",\n        deactivateEvents: \"deactivate\",\n        attachEvents: \"attach\",\n        detachEvents: \"detach\"\n      },\n      exportAs: [\"outlet\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass OutletInjector {\n  route;\n  childContexts;\n  parent;\n  outletData;\n  constructor(route, childContexts, parent, outletData) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n    this.outletData = outletData;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n}\nconst INPUT_BINDER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router Input Binder' : '');\nlet RoutedComponentInputBinder = /*#__PURE__*/(() => {\n  class RoutedComponentInputBinder {\n    outletDataSubscriptions = new Map();\n    bindActivatedRouteToOutletComponent(outlet) {\n      this.unsubscribeFromRouteData(outlet);\n      this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n      this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n      this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n      const {\n        activatedRoute\n      } = outlet;\n      const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n        data = {\n          ...queryParams,\n          ...params,\n          ...data\n        };\n        if (index === 0) {\n          return of(data);\n        }\n        return Promise.resolve(data);\n      })).subscribe(data => {\n        if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        for (const {\n          templateName\n        } of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n      this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    static ɵfac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RoutedComponentInputBinder)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RoutedComponentInputBinder,\n      factory: RoutedComponentInputBinder.ɵfac\n    });\n  }\n  return RoutedComponentInputBinder;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ɵEmptyOutletComponent = /*#__PURE__*/(() => {\n  class ɵEmptyOutletComponent {\n    static ɵfac = function ɵEmptyOutletComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ɵEmptyOutletComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ɵEmptyOutletComponent,\n      selectors: [[\"ng-component\"]],\n      exportAs: [\"emptyRouterOutlet\"],\n      decls: 1,\n      vars: 0,\n      template: function _EmptyOutletComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"router-outlet\");\n        }\n      },\n      dependencies: [RouterOutlet],\n      encapsulation: 2\n    });\n  }\n  return ɵEmptyOutletComponent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction standardizeConfig(r) {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {\n    ...r,\n    children\n  } : {\n    ...r\n  };\n  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = ɵEmptyOutletComponent;\n  }\n  return c;\n}\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = detachedRouteHandle.route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n    return new TreeNode(value, children);\n  }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\nclass RedirectCommand {\n  redirectTo;\n  navigationBehaviorOptions;\n  constructor(redirectTo, navigationBehaviorOptions) {\n    this.redirectTo = redirectTo;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\nfunction redirectingNavigationError(urlSerializer, redirect) {\n  const {\n    redirectTo,\n    navigationBehaviorOptions\n  } = isUrlTree(redirect) ? {\n    redirectTo: redirect,\n    navigationBehaviorOptions: undefined\n  } : redirect;\n  const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\nfunction navigationCancelingError(message, code) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`);\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n  return isNavigationCancelingError(error) && isUrlTree(error.url);\n}\nfunction isNavigationCancelingError(error) {\n  return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\nlet warnedAboutUnsupportedInputBinding = false;\nclass ActivateRoutes {\n  routeReuseStrategy;\n  futureState;\n  currState;\n  forwardEvent;\n  inputBindingEnabled;\n  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n    this.inputBindingEnabled = inputBindingEnabled;\n  }\n  activate(parentContexts) {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n  deactivateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n    Object.values(children).forEach(v => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n  deactivateRoutes(futureNode, currNode, parentContext) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    if (future === curr) {\n      if (future.component) {\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n  deactivateRouteAndItsChildren(route, parentContexts) {\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n  detachAndStoreRouteSubtree(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {\n        componentRef,\n        route,\n        contexts\n      });\n    }\n  }\n  deactivateRouteAndOutlet(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context) {\n      if (context.outlet) {\n        context.outlet.deactivate();\n        context.children.onOutletDeactivated();\n      }\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n  activateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n  activateRoutes(futureNode, currNode, parentContexts) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    advanceActivatedRoute(future);\n    if (future === curr) {\n      if (future.component) {\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = this.routeReuseStrategy.retrieve(future.snapshot);\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            context.outlet.activateWith(future, context.injector);\n          }\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {\n        console.warn(`'withComponentInputBinding' feature is enabled but ` + `this application is using an outlet that may not support binding to component inputs.`);\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\nclass CanActivate {\n  path;\n  route;\n  constructor(path) {\n    this.path = path;\n    this.route = this.path[this.path.length - 1];\n  }\n}\nclass CanDeactivate {\n  component;\n  route;\n  constructor(component, route) {\n    this.component = component;\n    this.route = route;\n  }\n}\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n  const NOT_FOUND = Symbol();\n  const result = injector.get(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\n      return tokenOrFunction;\n    } else {\n      return injector.get(tokenOrFunction);\n    }\n  }\n  return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const prevChildren = nodeChildrenAsMap(currNode);\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n  return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n  return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === 'function') {\n    return runInInjectionContext(future._environmentInjector, () => mode(curr, future));\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'always':\n      return true;\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\nfunction isBoolean(v) {\n  return typeof v === 'boolean';\n}\nfunction isCanLoad(guard) {\n  return guard && isFunction(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n  return guard && isFunction(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n  return guard && isFunction(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n  return guard && isFunction(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n  return guard && isFunction(guard.canMatch);\n}\nfunction isEmptyError(e) {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\nconst INITIAL_VALUE = /* @__PURE__ */Symbol('INITIAL_VALUE');\nfunction prioritizedGuardValue() {\n  return switchMap(obs => {\n    return combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map(results => {\n      for (const result of results) {\n        if (result === true) {\n          continue;\n        } else if (result === INITIAL_VALUE) {\n          return INITIAL_VALUE;\n        } else if (result === false || isRedirect(result)) {\n          return result;\n        }\n      }\n      return true;\n    }), filter(item => item !== INITIAL_VALUE), take(1));\n  });\n}\nfunction isRedirect(val) {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\nfunction abortSignalToObservable(signal) {\n  if (signal.aborted) {\n    return of(undefined).pipe(take(1));\n  }\n  return new Observable(subscriber => {\n    const handler = () => {\n      subscriber.next();\n      subscriber.complete();\n    };\n    signal.addEventListener('abort', handler);\n    return () => signal.removeEventListener('abort', handler);\n  });\n}\nfunction takeUntilAbort(signal) {\n  return takeUntil(abortSignalToObservable(signal));\n}\nfunction checkGuards(forwardEvent) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {\n        canActivateChecks,\n        canDeactivateChecks\n      }\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({\n        ...t,\n        guardsResult: true\n      });\n    }\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot).pipe(mergeMap(canDeactivate => {\n      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, forwardEvent) : of(canDeactivate);\n    }), map(guardsResult => ({\n      ...t,\n      guardsResult\n    })));\n  });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS) {\n  return from(checks).pipe(mergeMap(check => runCanDeactivate(check.component, check.route, currRSS, futureRSS)), first(result => {\n    return result !== true;\n  }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, forwardEvent) {\n  return from(checks).pipe(concatMap(check => {\n    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path), runCanActivate(futureSnapshot, check.route));\n  }), first(result => {\n    return result !== true;\n  }, true));\n}\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS) {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  const canActivateObservables = canActivate.map(canActivate => {\n    return defer(() => {\n      const closestInjector = futureARS._environmentInjector;\n      const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path) {\n  const futureARS = path[path.length - 1];\n  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(p => getCanActivateChild(p)).filter(_ => _ !== null);\n  const canActivateChildGuardsMapped = canActivateChildGuards.map(d => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(canActivateChild => {\n        const closestInjector = d.node._environmentInjector;\n        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS) {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map(c => {\n    const closestInjector = currARS._environmentInjector;\n    const guard = getTokenOrFunctionIdentity(c, closestInjector);\n    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer, abortSignal) {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n  const canLoadObservables = canLoad.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    const obs$ = wrapIntoObservable(guardVal);\n    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;\n  });\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n  return pipe(tap(result => {\n    if (typeof result === 'boolean') return;\n    throw redirectingNavigationError(urlSerializer, result);\n  }), map(result => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal) {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n  const canMatchObservables = canMatch.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    return wrapIntoObservable(guardVal).pipe(takeUntilAbort(abortSignal));\n  });\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nclass NoMatch extends Error {\n  segmentGroup;\n  constructor(segmentGroup) {\n    super();\n    this.segmentGroup = segmentGroup || null;\n    Object.setPrototypeOf(this, NoMatch.prototype);\n  }\n}\nclass AbsoluteRedirect extends Error {\n  urlTree;\n  constructor(urlTree) {\n    super();\n    this.urlTree = urlTree;\n    Object.setPrototypeOf(this, AbsoluteRedirect.prototype);\n  }\n}\nfunction namedOutletsRedirect(redirectTo) {\n  throw new _RuntimeError(4000, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`);\n}\nfunction canLoadFails(route) {\n  throw navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected);\n}\nclass ApplyRedirects {\n  urlSerializer;\n  urlTree;\n  constructor(urlSerializer, urlTree) {\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n  }\n  async lineralizeSegments(route, urlTree) {\n    let res = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return res;\n      }\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        throw namedOutletsRedirect(`${route.redirectTo}`);\n      }\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n  async applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n    const redirect = await getRedirectResult(redirectTo, currentSnapshot, injector);\n    if (redirect instanceof UrlTree) {\n      throw new AbsoluteRedirect(redirect);\n    }\n    const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);\n    if (redirect[0] === '/') {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n  }\n  createQueryParams(redirectToParams, actualParams) {\n    const res = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n  createSegmentGroup(redirectTo, group, segments, posParams) {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n    let children = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));\n  }\n  findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos) throw new _RuntimeError(4001, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n  findOrReturn(redirectToUrlSegment, actualSegments) {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\nfunction getRedirectResult(redirectTo, currentSnapshot, injector) {\n  if (typeof redirectTo === 'string') {\n    return Promise.resolve(redirectTo);\n  }\n  const redirectToFn = redirectTo;\n  const {\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    params,\n    data,\n    title,\n    paramMap,\n    queryParamMap\n  } = currentSnapshot;\n  return firstValueFrom(wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({\n    params,\n    data,\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    title,\n    paramMap,\n    queryParamMap\n  }))));\n}\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\n  for (let i = 0; i < config.length; i++) {\n    const route = config[i];\n    const fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\nfunction assertStandalone(fullPath, component) {\n  if (component && _isNgModule(component)) {\n    throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` + `but it must be used with standalone components. Use 'loadChildren' instead.`);\n  } else if (component && !isStandalone(component)) {\n    throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new _RuntimeError(4014, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo) {\n      if (route.component || route.loadComponent) {\n        throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n      }\n      if (route.canMatch || route.canActivate) {\n        throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` + `Redirects happen before guards are executed.`);\n      }\n    }\n    if (route.path && route.matcher) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new _RuntimeError(4014, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\nfunction sortByMatchingOutlets(routes, outletName) {\n  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\nconst noMatch = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer, abortSignal) {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal).pipe(map(v => v === true ? result : {\n    ...noMatch\n  }));\n}\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        ...noMatch\n      };\n    }\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {\n    ...noMatch\n  };\n  const posParams = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ? {\n    ...posParams,\n    ...res.consumed[res.consumed.length - 1].parameters\n  } : posParams;\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: s,\n      slicedSegments: []\n    };\n  }\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n    return {\n      segmentGroup: s,\n      slicedSegments\n    };\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {\n    segmentGroup: s,\n    slicedSegments\n  };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  const res = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {\n    ...children,\n    ...res\n  };\n}\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\n  const res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n  return r.path === '';\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\nclass NoLeftoversInUrl {}\nasync function recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly', abortSignal) {\n  return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal).recognize();\n}\nconst MAX_ALLOWED_REDIRECTS = 31;\nclass Recognizer {\n  injector;\n  configLoader;\n  rootComponentType;\n  config;\n  urlTree;\n  paramsInheritanceStrategy;\n  urlSerializer;\n  abortSignal;\n  applyRedirects;\n  absoluteRedirectCount = 0;\n  allowRedirects = true;\n  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal) {\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.urlSerializer = urlSerializer;\n    this.abortSignal = abortSignal;\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n  noMatchError(e) {\n    return new _RuntimeError(4002, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);\n  }\n  async recognize() {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n    const {\n      children,\n      rootSnapshot\n    } = await this.match(rootSegmentGroup);\n    const rootNode = new TreeNode(rootSnapshot, children);\n    const routeState = new RouterStateSnapshot('', rootNode);\n    const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n    tree.queryParams = this.urlTree.queryParams;\n    routeState.url = this.urlSerializer.serialize(tree);\n    return {\n      state: routeState,\n      tree\n    };\n  }\n  async match(rootSegmentGroup) {\n    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {}, this.injector);\n    try {\n      const children = await this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot);\n      return {\n        children,\n        rootSnapshot\n      };\n    } catch (e) {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n      throw e;\n    }\n  }\n  async processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n    const child = await this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute);\n    return child instanceof TreeNode ? [child] : [];\n  }\n  async processChildren(injector, config, segmentGroup, parentRoute) {\n    const childOutlets = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    let children = [];\n    for (const childOutlet of childOutlets) {\n      const child = segmentGroup.children[childOutlet];\n      const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n      const outletChildren = await this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n      children.push(...outletChildren);\n    }\n    const mergedChildren = mergeEmptyPathMatches(children);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      checkOutletNameUniqueness(mergedChildren);\n    }\n    sortActivatedRouteSnapshots(mergedChildren);\n    return mergedChildren;\n  }\n  async processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n    for (const r of routes) {\n      try {\n        return await this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute);\n      } catch (e) {\n        if (e instanceof NoMatch || isEmptyError(e)) {\n          continue;\n        }\n        throw e;\n      }\n    }\n    if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n      return new NoLeftoversInUrl();\n    }\n    throw new NoMatch(segmentGroup);\n  }\n  async processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n      throw new NoMatch(rawSegment);\n    }\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n    }\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n    }\n    throw new NoMatch(rawSegment);\n  }\n  async expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n    const {\n      matched,\n      parameters,\n      consumedSegments,\n      positionalParamSegments,\n      remainingSegments\n    } = match(segmentGroup, route, segments);\n    if (!matched) throw new NoMatch(segmentGroup);\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new _RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route), injector);\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    if (this.abortSignal.aborted) {\n      throw new Error(this.abortSignal.reason);\n    }\n    const newTree = await this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n    const newSegments = await this.applyRedirects.lineralizeSegments(route, newTree);\n    return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n  }\n  async matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n    if (this.abortSignal.aborted) {\n      throw new Error(this.abortSignal.reason);\n    }\n    const result = await firstValueFrom(matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer, this.abortSignal));\n    if (route.path === '**') {\n      rawSegment.children = {};\n    }\n    if (!result?.matched) {\n      throw new NoMatch(rawSegment);\n    }\n    injector = route._injector ?? injector;\n    const {\n      routes: childConfig\n    } = await this.getChildConfig(injector, route, segments);\n    const childInjector = route._loadedInjector ?? injector;\n    const {\n      parameters,\n      consumedSegments,\n      remainingSegments\n    } = result;\n    const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route), injector);\n    const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n    snapshot.params = Object.freeze(inherited.params);\n    snapshot.data = Object.freeze(inherited.data);\n    const {\n      segmentGroup,\n      slicedSegments\n    } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n      const children = await this.processChildren(childInjector, childConfig, segmentGroup, snapshot);\n      return new TreeNode(snapshot, children);\n    }\n    if (childConfig.length === 0 && slicedSegments.length === 0) {\n      return new TreeNode(snapshot, []);\n    }\n    const matchedOnOutlet = getOutlet(route) === outlet;\n    const child = await this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot);\n    return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n  }\n  async getChildConfig(injector, route, segments) {\n    if (route.children) {\n      return {\n        routes: route.children,\n        injector\n      };\n    }\n    if (route.loadChildren) {\n      if (route._loadedRoutes !== undefined) {\n        const ngModuleFactory = route._loadedNgModuleFactory;\n        if (ngModuleFactory && !route._loadedInjector) {\n          route._loadedInjector = ngModuleFactory.create(injector).injector;\n        }\n        return {\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        };\n      }\n      if (this.abortSignal.aborted) {\n        throw new Error(this.abortSignal.reason);\n      }\n      const shouldLoadResult = await firstValueFrom(runCanLoadGuards(injector, route, segments, this.urlSerializer, this.abortSignal));\n      if (shouldLoadResult) {\n        const cfg = await this.configLoader.loadChildren(injector, route);\n        route._loadedRoutes = cfg.routes;\n        route._loadedInjector = cfg.injector;\n        route._loadedNgModuleFactory = cfg.factory;\n        return cfg;\n      }\n      throw canLoadFails(route);\n    }\n    return {\n      routes: [],\n      injector\n    };\n  }\n}\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\nfunction hasEmptyPathConfig(node) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\nfunction mergeEmptyPathMatches(nodes) {\n  const result = [];\n  const mergedNodes = new Set();\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n  const names = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new _RuntimeError(4006, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\nfunction getData(route) {\n  return route.data || {};\n}\nfunction getResolve(route) {\n  return route.resolve || {};\n}\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy, abortSignal) {\n  return mergeMap(async t => {\n    const {\n      state: targetSnapshot,\n      tree: urlAfterRedirects\n    } = await recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy, abortSignal);\n    return {\n      ...t,\n      targetSnapshot,\n      urlAfterRedirects\n    };\n  });\n}\nfunction resolveData(paramsInheritanceStrategy) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      guards: {\n        canActivateChecks\n      }\n    } = t;\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    const routesWithResolversToRun = new Set(canActivateChecks.map(check => check.route));\n    const routesNeedingDataUpdates = new Set();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(concatMap(route => {\n      if (routesWithResolversToRun.has(route)) {\n        return runResolve(route, targetSnapshot, paramsInheritanceStrategy);\n      } else {\n        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n        return of(void 0);\n      }\n    }), tap(() => routesProcessed++), takeLast(1), mergeMap(_ => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));\n  });\n}\nfunction flattenRouteTree(route) {\n  const descendants = route.children.map(child => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return defer(() => {\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return resolveNode(resolve, futureARS, futureRSS).pipe(map(resolvedData => {\n      futureARS._resolvedData = resolvedData;\n      futureARS.data = {\n        ...futureARS.data,\n        ...resolvedData\n      };\n      return null;\n    }));\n  });\n}\nfunction resolveNode(resolve, futureARS, futureRSS) {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data = {};\n  return from(keys).pipe(mergeMap(key => getResolver(resolve[key], futureARS, futureRSS).pipe(first(), tap(value => {\n    if (value instanceof RedirectCommand) {\n      throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n    }\n    data[key] = value;\n  }))), takeLast(1), map(() => data), catchError(e => isEmptyError(e) ? EMPTY : throwError(e)));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS) {\n  const closestInjector = futureARS._environmentInjector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\nfunction switchTap(next) {\n  return switchMap(v => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\nlet TitleStrategy = /*#__PURE__*/(() => {\n  class TitleStrategy {\n    buildTitle(snapshot) {\n      let pageTitle;\n      let route = snapshot.root;\n      while (route !== undefined) {\n        pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n        route = route.children.find(child => child.outlet === PRIMARY_OUTLET);\n      }\n      return pageTitle;\n    }\n    getResolvedTitleForRoute(snapshot) {\n      return snapshot.data[RouteTitleKey];\n    }\n    static ɵfac = function TitleStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TitleStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TitleStrategy,\n      factory: () => (() => inject(DefaultTitleStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return TitleStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DefaultTitleStrategy = /*#__PURE__*/(() => {\n  class DefaultTitleStrategy extends TitleStrategy {\n    title;\n    constructor(title) {\n      super();\n      this.title = title;\n    }\n    updateTitle(snapshot) {\n      const title = this.buildTitle(snapshot);\n      if (title !== undefined) {\n        this.title.setTitle(title);\n      }\n    }\n    static ɵfac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultTitleStrategy)(i0.ɵɵinject(i1.Title));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultTitleStrategy,\n      factory: DefaultTitleStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultTitleStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ROUTER_CONFIGURATION = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\n  factory: () => ({})\n});\nconst ROUTES = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROUTES' : '');\nlet RouterConfigLoader = /*#__PURE__*/(() => {\n  class RouterConfigLoader {\n    componentLoaders = new WeakMap();\n    childrenLoaders = new WeakMap();\n    onLoadStartListener;\n    onLoadEndListener;\n    compiler = inject(Compiler);\n    async loadComponent(injector, route) {\n      if (this.componentLoaders.get(route)) {\n        return this.componentLoaders.get(route);\n      } else if (route._loadedComponent) {\n        return Promise.resolve(route._loadedComponent);\n      }\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n      const loader = (async () => {\n        try {\n          const loaded = await wrapIntoPromise(runInInjectionContext(injector, () => route.loadComponent()));\n          const component = await maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n          if (this.onLoadEndListener) {\n            this.onLoadEndListener(route);\n          }\n          (typeof ngDevMode === 'undefined' || ngDevMode) && assertStandalone(route.path ?? '', component);\n          route._loadedComponent = component;\n          return component;\n        } finally {\n          this.componentLoaders.delete(route);\n        }\n      })();\n      this.componentLoaders.set(route, loader);\n      return loader;\n    }\n    loadChildren(parentInjector, route) {\n      if (this.childrenLoaders.get(route)) {\n        return this.childrenLoaders.get(route);\n      } else if (route._loadedRoutes) {\n        return Promise.resolve({\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        });\n      }\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n      const loader = (async () => {\n        try {\n          const result = await loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n          route._loadedRoutes = result.routes;\n          route._loadedInjector = result.injector;\n          route._loadedNgModuleFactory = result.factory;\n          return result;\n        } finally {\n          this.childrenLoaders.delete(route);\n        }\n      })();\n      this.childrenLoaders.set(route, loader);\n      return loader;\n    }\n    static ɵfac = function RouterConfigLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterConfigLoader)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterConfigLoader,\n      factory: RouterConfigLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RouterConfigLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nasync function loadChildren(route, compiler, parentInjector, onLoadEndListener) {\n  const loaded = await wrapIntoPromise(runInInjectionContext(parentInjector, () => route.loadChildren()));\n  const t = await maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n  let factoryOrRoutes;\n  if (t instanceof NgModuleFactory || Array.isArray(t)) {\n    factoryOrRoutes = t;\n  } else {\n    factoryOrRoutes = await compiler.compileModuleAsync(t);\n  }\n  if (onLoadEndListener) {\n    onLoadEndListener(route);\n  }\n  let injector;\n  let rawRoutes;\n  let requireStandaloneComponents = false;\n  let factory = undefined;\n  if (Array.isArray(factoryOrRoutes)) {\n    rawRoutes = factoryOrRoutes;\n    requireStandaloneComponents = true;\n  } else {\n    injector = factoryOrRoutes.create(parentInjector).injector;\n    factory = factoryOrRoutes;\n    rawRoutes = injector.get(ROUTES, [], {\n      optional: true,\n      self: true\n    }).flat();\n  }\n  const routes = rawRoutes.map(standardizeConfig);\n  (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(routes, route.path, requireStandaloneComponents);\n  return {\n    routes,\n    injector,\n    factory\n  };\n}\nfunction isWrappedDefaultExport(value) {\n  return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\nasync function maybeResolveResources(value) {\n  if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n    try {\n      await _resolveComponentResources(fetch);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return value;\n}\nlet UrlHandlingStrategy = /*#__PURE__*/(() => {\n  class UrlHandlingStrategy {\n    static ɵfac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UrlHandlingStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: UrlHandlingStrategy,\n      factory: () => (() => inject(DefaultUrlHandlingStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return UrlHandlingStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DefaultUrlHandlingStrategy = /*#__PURE__*/(() => {\n  class DefaultUrlHandlingStrategy {\n    shouldProcessUrl(url) {\n      return true;\n    }\n    extract(url) {\n      return url;\n    }\n    merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n    static ɵfac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultUrlHandlingStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultUrlHandlingStrategy,\n      factory: DefaultUrlHandlingStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultUrlHandlingStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CREATE_VIEW_TRANSITION = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition helper' : '');\nconst VIEW_TRANSITION_OPTIONS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition options' : '');\nfunction createViewTransition(injector, from, to) {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n    transitionOptions.skipNextTransition = false;\n    return new Promise(resolve => setTimeout(resolve));\n  }\n  let resolveViewTransitionStarted;\n  const viewTransitionStarted = new Promise(resolve => {\n    resolveViewTransitionStarted = resolve;\n  });\n  const transition = document.startViewTransition(() => {\n    resolveViewTransitionStarted();\n    return createRenderPromise(injector);\n  });\n  transition.updateCallbackDone.catch(error => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  transition.ready.catch(error => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  transition.finished.catch(error => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  const {\n    onViewTransitionCreated\n  } = transitionOptions;\n  if (onViewTransitionCreated) {\n    runInInjectionContext(injector, () => onViewTransitionCreated({\n      transition,\n      from,\n      to\n    }));\n  }\n  return viewTransitionStarted;\n}\nfunction createRenderPromise(injector) {\n  return new Promise(resolve => {\n    afterNextRender({\n      read: () => setTimeout(resolve)\n    }, {\n      injector\n    });\n  });\n}\nconst noop = () => {};\nconst NAVIGATION_ERROR_HANDLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\nlet NavigationTransitions = /*#__PURE__*/(() => {\n  class NavigationTransitions {\n    currentNavigation = signal(null, {\n      ...(ngDevMode ? {\n        debugName: \"currentNavigation\"\n      } : {}),\n      equal: () => false\n    });\n    currentTransition = null;\n    lastSuccessfulNavigation = signal(null, ...(ngDevMode ? [{\n      debugName: \"lastSuccessfulNavigation\"\n    }] : []));\n    events = new Subject();\n    transitionAbortWithErrorSubject = new Subject();\n    configLoader = inject(RouterConfigLoader);\n    environmentInjector = inject(EnvironmentInjector);\n    destroyRef = inject(DestroyRef);\n    urlSerializer = inject(UrlSerializer);\n    rootContexts = inject(ChildrenOutletContexts);\n    location = inject(Location);\n    inputBindingEnabled = inject(INPUT_BINDER, {\n      optional: true\n    }) !== null;\n    titleStrategy = inject(TitleStrategy);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    createViewTransition = inject(CREATE_VIEW_TRANSITION, {\n      optional: true\n    });\n    navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {\n      optional: true\n    });\n    navigationId = 0;\n    get hasRequestedNavigation() {\n      return this.navigationId !== 0;\n    }\n    transitions;\n    afterPreactivation = () => of(void 0);\n    rootComponentType = null;\n    destroyed = false;\n    constructor() {\n      const onLoadStart = r => this.events.next(new RouteConfigLoadStart(r));\n      const onLoadEnd = r => this.events.next(new RouteConfigLoadEnd(r));\n      this.configLoader.onLoadEndListener = onLoadEnd;\n      this.configLoader.onLoadStartListener = onLoadStart;\n      this.destroyRef.onDestroy(() => {\n        this.destroyed = true;\n      });\n    }\n    complete() {\n      this.transitions?.complete();\n    }\n    handleNavigationRequest(request) {\n      const id = ++this.navigationId;\n      untracked(() => {\n        this.transitions?.next({\n          ...request,\n          extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n          targetSnapshot: null,\n          targetRouterState: null,\n          guards: {\n            canActivateChecks: [],\n            canDeactivateChecks: []\n          },\n          guardsResult: null,\n          id\n        });\n      });\n    }\n    setupNavigations(router) {\n      this.transitions = new BehaviorSubject(null);\n      return this.transitions.pipe(filter(t => t !== null), switchMap(overallTransitionState => {\n        let completedOrAborted = false;\n        const abortController = new AbortController();\n        const shouldContinueNavigation = () => {\n          return !completedOrAborted && this.currentTransition?.id === overallTransitionState.id;\n        };\n        return of(overallTransitionState).pipe(switchMap(t => {\n          if (this.navigationId > overallTransitionState.id) {\n            const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n            this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n            return EMPTY;\n          }\n          this.currentTransition = overallTransitionState;\n          const lastSuccessfulNavigation = this.lastSuccessfulNavigation();\n          this.currentNavigation.set({\n            id: t.id,\n            initialUrl: t.rawUrl,\n            extractedUrl: t.extractedUrl,\n            targetBrowserUrl: typeof t.extras.browserUrl === 'string' ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,\n            trigger: t.source,\n            extras: t.extras,\n            previousNavigation: !lastSuccessfulNavigation ? null : {\n              ...lastSuccessfulNavigation,\n              previousNavigation: null\n            },\n            abort: () => abortController.abort()\n          });\n          const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n          const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n          if (!urlTransition && onSameUrlNavigation !== 'reload') {\n            const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : '';\n            this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n            t.resolve(false);\n            return EMPTY;\n          }\n          if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n            return of(t).pipe(switchMap(t => {\n              this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\n              if (t.id !== this.navigationId) {\n                return EMPTY;\n              }\n              return Promise.resolve(t);\n            }), recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy, abortController.signal), tap(t => {\n              overallTransitionState.targetSnapshot = t.targetSnapshot;\n              overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n              this.currentNavigation.update(nav => {\n                nav.finalUrl = t.urlAfterRedirects;\n                return nav;\n              });\n              const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n              this.events.next(routesRecognized);\n            }));\n          } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n            const {\n              id,\n              extractedUrl,\n              source,\n              restoredState,\n              extras\n            } = t;\n            const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n            this.events.next(navStart);\n            const targetSnapshot = createEmptyState(this.rootComponentType, this.environmentInjector).snapshot;\n            this.currentTransition = overallTransitionState = {\n              ...t,\n              targetSnapshot,\n              urlAfterRedirects: extractedUrl,\n              extras: {\n                ...extras,\n                skipLocationChange: false,\n                replaceUrl: false\n              }\n            };\n            this.currentNavigation.update(nav => {\n              nav.finalUrl = extractedUrl;\n              return nav;\n            });\n            return of(overallTransitionState);\n          } else {\n            const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy` + ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : '';\n            this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n            t.resolve(false);\n            return EMPTY;\n          }\n        }), map(t => {\n          const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n          this.events.next(guardsStart);\n          this.currentTransition = overallTransitionState = {\n            ...t,\n            guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)\n          };\n          return overallTransitionState;\n        }), checkGuards(evt => this.events.next(evt)), switchMap(t => {\n          overallTransitionState.guardsResult = t.guardsResult;\n          if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n            throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n          }\n          const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n          this.events.next(guardsEnd);\n          if (!shouldContinueNavigation()) {\n            return EMPTY;\n          }\n          if (!t.guardsResult) {\n            this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n            return EMPTY;\n          }\n          if (t.guards.canActivateChecks.length === 0) {\n            return of(t);\n          }\n          const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n          this.events.next(resolveStart);\n          if (!shouldContinueNavigation()) {\n            return EMPTY;\n          }\n          let dataResolved = false;\n          return of(t).pipe(resolveData(this.paramsInheritanceStrategy), tap({\n            next: () => {\n              dataResolved = true;\n              const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n              this.events.next(resolveEnd);\n            },\n            complete: () => {\n              if (!dataResolved) {\n                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode ? `At least one route resolver didn't emit any value.` : '', NavigationCancellationCode.NoDataFromResolver);\n              }\n            }\n          }));\n        }), switchTap(t => {\n          const loadComponents = route => {\n            const loaders = [];\n            if (route.routeConfig?._loadedComponent) {\n              route.component = route.routeConfig?._loadedComponent;\n            } else if (route.routeConfig?.loadComponent) {\n              const injector = route._environmentInjector;\n              loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).then(loadedComponent => {\n                route.component = loadedComponent;\n              }));\n            }\n            for (const child of route.children) {\n              loaders.push(...loadComponents(child));\n            }\n            return loaders;\n          };\n          const loaders = loadComponents(t.targetSnapshot.root);\n          return loaders.length === 0 ? of(t) : from(Promise.all(loaders).then(() => t));\n        }), switchTap(() => this.afterPreactivation()), switchMap(() => {\n          const {\n            currentSnapshot,\n            targetSnapshot\n          } = overallTransitionState;\n          const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n          return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);\n        }), take(1), map(t => {\n          const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n          this.currentTransition = overallTransitionState = t = {\n            ...t,\n            targetRouterState\n          };\n          this.currentNavigation.update(nav => {\n            nav.targetRouterState = targetRouterState;\n            return nav;\n          });\n          this.events.next(new BeforeActivateRoutes());\n          if (!shouldContinueNavigation()) {\n            return;\n          }\n          new ActivateRoutes(router.routeReuseStrategy, overallTransitionState.targetRouterState, overallTransitionState.currentRouterState, evt => this.events.next(evt), this.inputBindingEnabled).activate(this.rootContexts);\n          if (!shouldContinueNavigation()) {\n            return;\n          }\n          completedOrAborted = true;\n          this.currentNavigation.update(nav => {\n            nav.abort = noop;\n            return nav;\n          });\n          this.lastSuccessfulNavigation.set(untracked(this.currentNavigation));\n          this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n          this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n          t.resolve(true);\n        }), takeUntil(abortSignalToObservable(abortController.signal).pipe(filter(() => !completedOrAborted && !overallTransitionState.targetRouterState), tap(() => {\n          this.cancelNavigationTransition(overallTransitionState, abortController.signal.reason + '', NavigationCancellationCode.Aborted);\n        }))), tap({\n          complete: () => {\n            completedOrAborted = true;\n          }\n        }), takeUntil(this.transitionAbortWithErrorSubject.pipe(tap(err => {\n          throw err;\n        }))), finalize(() => {\n          abortController.abort();\n          if (!completedOrAborted) {\n            const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n            this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n          }\n          if (this.currentTransition?.id === overallTransitionState.id) {\n            this.currentNavigation.set(null);\n            this.currentTransition = null;\n          }\n        }), catchError(e => {\n          completedOrAborted = true;\n          if (this.destroyed) {\n            overallTransitionState.resolve(false);\n            return EMPTY;\n          }\n          if (isNavigationCancelingError(e)) {\n            this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n            if (!isRedirectingNavigationCancelingError(e)) {\n              overallTransitionState.resolve(false);\n            } else {\n              this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n            }\n          } else {\n            const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\n            try {\n              const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n              if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                const {\n                  message,\n                  cancellationCode\n                } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n                this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n                this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n              } else {\n                this.events.next(navigationError);\n                throw e;\n              }\n            } catch (ee) {\n              if (this.options.resolveNavigationPromiseOnError) {\n                overallTransitionState.resolve(false);\n              } else {\n                overallTransitionState.reject(ee);\n              }\n            }\n          }\n          return EMPTY;\n        }));\n      }));\n    }\n    cancelNavigationTransition(t, reason, code) {\n      const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n      this.events.next(navCancel);\n      t.resolve(false);\n    }\n    isUpdatingInternalState() {\n      return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();\n    }\n    isUpdatedBrowserUrl() {\n      const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n      const currentNavigation = untracked(this.currentNavigation);\n      const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;\n      return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !currentNavigation?.extras.skipLocationChange;\n    }\n    static ɵfac = function NavigationTransitions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NavigationTransitions)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NavigationTransitions,\n      factory: NavigationTransitions.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NavigationTransitions;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isBrowserTriggeredNavigation(source) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\nconst ROUTE_INJECTOR_CLEANUP = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'RouteInjectorCleanup' : '');\nfunction routeInjectorCleanup(routeReuseStrategy, routerState, config) {\n  const activeRoutes = new Set();\n  if (routerState.snapshot.root) {\n    collectDescendants(routerState.snapshot.root, activeRoutes);\n  }\n  const storedHandles = routeReuseStrategy.retrieveStoredRouteHandles?.() || [];\n  for (const handle of storedHandles) {\n    const internalHandle = handle;\n    if (internalHandle?.route?.value?.snapshot) {\n      for (const snapshot of internalHandle.route.value.snapshot.pathFromRoot) {\n        if (snapshot.routeConfig) {\n          activeRoutes.add(snapshot.routeConfig);\n        }\n      }\n    }\n  }\n  destroyUnusedInjectors(config, activeRoutes, routeReuseStrategy, false);\n}\nfunction collectDescendants(snapshot, activeRoutes) {\n  if (snapshot.routeConfig) {\n    activeRoutes.add(snapshot.routeConfig);\n  }\n  for (const child of snapshot.children) {\n    collectDescendants(child, activeRoutes);\n  }\n}\nfunction destroyUnusedInjectors(routes, activeRoutes, strategy, inheritedForceDestroy) {\n  for (const route of routes) {\n    const shouldDestroyCurrentRoute = inheritedForceDestroy || !!((route._injector || route._loadedInjector) && !activeRoutes.has(route) && (strategy.shouldDestroyInjector?.(route) ?? false));\n    if (route.children) {\n      destroyUnusedInjectors(route.children, activeRoutes, strategy, shouldDestroyCurrentRoute);\n    }\n    if (route.loadChildren && route._loadedRoutes) {\n      destroyUnusedInjectors(route._loadedRoutes, activeRoutes, strategy, shouldDestroyCurrentRoute);\n    }\n    if (shouldDestroyCurrentRoute) {\n      if (route._injector) {\n        route._injector.destroy();\n        route._injector = undefined;\n      }\n      if (route._loadedInjector) {\n        route._loadedInjector.destroy();\n        route._loadedInjector = undefined;\n      }\n    }\n  }\n}\nfunction destroyDetachedRouteHandle(handle) {\n  const internalHandle = handle;\n  if (internalHandle && internalHandle.componentRef) {\n    internalHandle.componentRef.destroy();\n  }\n}\nlet RouteReuseStrategy = /*#__PURE__*/(() => {\n  class RouteReuseStrategy {\n    static ɵfac = function RouteReuseStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouteReuseStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouteReuseStrategy,\n      factory: () => (() => inject(DefaultRouteReuseStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return RouteReuseStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass BaseRouteReuseStrategy {\n  shouldDetach(route) {\n    return false;\n  }\n  store(route, detachedTree) {}\n  shouldAttach(route) {\n    return false;\n  }\n  retrieve(route) {\n    return null;\n  }\n  shouldReuseRoute(future, curr) {\n    return future.routeConfig === curr.routeConfig;\n  }\n  shouldDestroyInjector(route) {\n    return true;\n  }\n}\nlet DefaultRouteReuseStrategy = /*#__PURE__*/(() => {\n  class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵDefaultRouteReuseStrategy_BaseFactory;\n      return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {\n        return (ɵDefaultRouteReuseStrategy_BaseFactory || (ɵDefaultRouteReuseStrategy_BaseFactory = i0.ɵɵgetInheritedFactory(DefaultRouteReuseStrategy)))(__ngFactoryType__ || DefaultRouteReuseStrategy);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultRouteReuseStrategy,\n      factory: DefaultRouteReuseStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultRouteReuseStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StateManager = /*#__PURE__*/(() => {\n  class StateManager {\n    urlSerializer = inject(UrlSerializer);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    currentUrlTree = new UrlTree();\n    getCurrentUrlTree() {\n      return this.currentUrlTree;\n    }\n    rawUrlTree = this.currentUrlTree;\n    getRawUrlTree() {\n      return this.rawUrlTree;\n    }\n    createBrowserPath({\n      finalUrl,\n      initialUrl,\n      targetBrowserUrl\n    }) {\n      const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\n      const url = targetBrowserUrl ?? rawUrl;\n      const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n      return path;\n    }\n    commitTransition({\n      targetRouterState,\n      finalUrl,\n      initialUrl\n    }) {\n      if (finalUrl && targetRouterState) {\n        this.currentUrlTree = finalUrl;\n        this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n        this.routerState = targetRouterState;\n      } else {\n        this.rawUrlTree = initialUrl;\n      }\n    }\n    routerState = createEmptyState(null, inject(EnvironmentInjector));\n    getRouterState() {\n      return this.routerState;\n    }\n    _stateMemento = this.createStateMemento();\n    get stateMemento() {\n      return this._stateMemento;\n    }\n    updateStateMemento() {\n      this._stateMemento = this.createStateMemento();\n    }\n    createStateMemento() {\n      return {\n        rawUrlTree: this.rawUrlTree,\n        currentUrlTree: this.currentUrlTree,\n        routerState: this.routerState\n      };\n    }\n    restoredState() {\n      return this.location.getState();\n    }\n    static ɵfac = function StateManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StateManager)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: StateManager,\n      factory: () => (() => inject(HistoryStateManager))(),\n      providedIn: 'root'\n    });\n  }\n  return StateManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HistoryStateManager = /*#__PURE__*/(() => {\n  class HistoryStateManager extends StateManager {\n    currentPageId = 0;\n    lastSuccessfulId = -1;\n    get browserPageId() {\n      if (this.canceledNavigationResolution !== 'computed') {\n        return this.currentPageId;\n      }\n      return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n    }\n    registerNonRouterCurrentEntryChangeListener(listener) {\n      return this.location.subscribe(event => {\n        if (event['type'] === 'popstate') {\n          setTimeout(() => {\n            listener(event['url'], event.state, 'popstate');\n          });\n        }\n      });\n    }\n    handleRouterEvent(e, currentTransition) {\n      if (e instanceof NavigationStart) {\n        this.updateStateMemento();\n      } else if (e instanceof NavigationSkipped) {\n        this.commitTransition(currentTransition);\n      } else if (e instanceof RoutesRecognized) {\n        if (this.urlUpdateStrategy === 'eager') {\n          if (!currentTransition.extras.skipLocationChange) {\n            this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n          }\n        }\n      } else if (e instanceof BeforeActivateRoutes) {\n        this.commitTransition(currentTransition);\n        if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      } else if (e instanceof NavigationCancel && !isRedirectingEvent(e)) {\n        this.restoreHistory(currentTransition);\n      } else if (e instanceof NavigationError) {\n        this.restoreHistory(currentTransition, true);\n      } else if (e instanceof NavigationEnd) {\n        this.lastSuccessfulId = e.id;\n        this.currentPageId = this.browserPageId;\n      }\n    }\n    setBrowserUrl(path, {\n      extras,\n      id\n    }) {\n      const {\n        replaceUrl,\n        state\n      } = extras;\n      if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n        const currentBrowserPageId = this.browserPageId;\n        const newState = {\n          ...state,\n          ...this.generateNgRouterState(id, currentBrowserPageId)\n        };\n        this.location.replaceState(path, '', newState);\n      } else {\n        const newState = {\n          ...state,\n          ...this.generateNgRouterState(id, this.browserPageId + 1)\n        };\n        this.location.go(path, '', newState);\n      }\n    }\n    restoreHistory(navigation, restoringFromCaughtError = false) {\n      if (this.canceledNavigationResolution === 'computed') {\n        const currentBrowserPageId = this.browserPageId;\n        const targetPagePosition = this.currentPageId - currentBrowserPageId;\n        if (targetPagePosition !== 0) {\n          this.location.historyGo(targetPagePosition);\n        } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n          this.resetInternalState(navigation);\n          this.resetUrlToCurrentUrlTree();\n        } else ;\n      } else if (this.canceledNavigationResolution === 'replace') {\n        if (restoringFromCaughtError) {\n          this.resetInternalState(navigation);\n        }\n        this.resetUrlToCurrentUrlTree();\n      }\n    }\n    resetInternalState({\n      finalUrl\n    }) {\n      this.routerState = this.stateMemento.routerState;\n      this.currentUrlTree = this.stateMemento.currentUrlTree;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n    }\n    resetUrlToCurrentUrlTree() {\n      this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n    }\n    generateNgRouterState(navigationId, routerPageId) {\n      if (this.canceledNavigationResolution === 'computed') {\n        return {\n          navigationId,\n          ɵrouterPageId: routerPageId\n        };\n      }\n      return {\n        navigationId\n      };\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵHistoryStateManager_BaseFactory;\n      return function HistoryStateManager_Factory(__ngFactoryType__) {\n        return (ɵHistoryStateManager_BaseFactory || (ɵHistoryStateManager_BaseFactory = i0.ɵɵgetInheritedFactory(HistoryStateManager)))(__ngFactoryType__ || HistoryStateManager);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HistoryStateManager,\n      factory: HistoryStateManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HistoryStateManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction afterNextNavigation(router, action) {\n  router.events.pipe(filter(e => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map(e => {\n    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n      return 0;\n    }\n    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;\n    return redirecting ? 2 : 1;\n  }), filter(result => result !== 2), take(1)).subscribe(() => {\n    action();\n  });\n}\nconst exactMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\nconst subsetMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\nlet Router = /*#__PURE__*/(() => {\n  class Router {\n    get currentUrlTree() {\n      return this.stateManager.getCurrentUrlTree();\n    }\n    get rawUrlTree() {\n      return this.stateManager.getRawUrlTree();\n    }\n    disposed = false;\n    nonRouterCurrentEntryChangeSubscription;\n    console = inject(_Console);\n    stateManager = inject(StateManager);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    pendingTasks = inject(_PendingTasksInternal);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    navigationTransitions = inject(NavigationTransitions);\n    urlSerializer = inject(UrlSerializer);\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    injector = inject(EnvironmentInjector);\n    _events = new Subject();\n    get events() {\n      return this._events;\n    }\n    get routerState() {\n      return this.stateManager.getRouterState();\n    }\n    navigated = false;\n    routeReuseStrategy = inject(RouteReuseStrategy);\n    injectorCleanup = inject(ROUTE_INJECTOR_CLEANUP, {\n      optional: true\n    });\n    onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n    config = inject(ROUTES, {\n      optional: true\n    })?.flat() ?? [];\n    componentInputBindingEnabled = !!inject(INPUT_BINDER, {\n      optional: true\n    });\n    currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();\n    constructor() {\n      this.resetConfig(this.config);\n      this.navigationTransitions.setupNavigations(this).subscribe({\n        error: e => {}\n      });\n      this.subscribeToNavigationEvents();\n    }\n    eventsSubscription = new Subscription();\n    subscribeToNavigationEvents() {\n      const subscription = this.navigationTransitions.events.subscribe(e => {\n        try {\n          const currentTransition = this.navigationTransitions.currentTransition;\n          const currentNavigation = untracked(this.navigationTransitions.currentNavigation);\n          if (currentTransition !== null && currentNavigation !== null) {\n            this.stateManager.handleRouterEvent(e, currentNavigation);\n            if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n              this.navigated = true;\n            } else if (e instanceof NavigationEnd) {\n              this.navigated = true;\n              this.injectorCleanup?.(this.routeReuseStrategy, this.routerState, this.config);\n            } else if (e instanceof RedirectRequest) {\n              const opts = e.navigationBehaviorOptions;\n              const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n              const extras = {\n                scroll: currentTransition.extras.scroll,\n                browserUrl: currentTransition.extras.browserUrl,\n                info: currentTransition.extras.info,\n                skipLocationChange: currentTransition.extras.skipLocationChange,\n                replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === 'eager' || isBrowserTriggeredNavigation(currentTransition.source),\n                ...opts\n              };\n              this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n                resolve: currentTransition.resolve,\n                reject: currentTransition.reject,\n                promise: currentTransition.promise\n              });\n            }\n          }\n          if (isPublicRouterEvent(e)) {\n            this._events.next(e);\n          }\n        } catch (e) {\n          this.navigationTransitions.transitionAbortWithErrorSubject.next(e);\n        }\n      });\n      this.eventsSubscription.add(subscription);\n    }\n    resetRootComponentType(rootComponentType) {\n      this.routerState.root.component = rootComponentType;\n      this.navigationTransitions.rootComponentType = rootComponentType;\n    }\n    initialNavigation() {\n      this.setUpLocationChangeListener();\n      if (!this.navigationTransitions.hasRequestedNavigation) {\n        this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n      }\n    }\n    setUpLocationChangeListener() {\n      this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n        this.navigateToSyncWithBrowser(url, source, state);\n      });\n    }\n    navigateToSyncWithBrowser(url, source, state) {\n      const extras = {\n        replaceUrl: true\n      };\n      const restoredState = state?.navigationId ? state : null;\n      if (state) {\n        const stateCopy = {\n          ...state\n        };\n        delete stateCopy.navigationId;\n        delete stateCopy.ɵrouterPageId;\n        if (Object.keys(stateCopy).length !== 0) {\n          extras.state = stateCopy;\n        }\n      }\n      const urlTree = this.parseUrl(url);\n      this.scheduleNavigation(urlTree, source, restoredState, extras).catch(e => {\n        if (this.disposed) {\n          return;\n        }\n        this.injector.get(_INTERNAL_APPLICATION_ERROR_HANDLER)(e);\n      });\n    }\n    get url() {\n      return this.serializeUrl(this.currentUrlTree);\n    }\n    getCurrentNavigation() {\n      return untracked(this.navigationTransitions.currentNavigation);\n    }\n    get lastSuccessfulNavigation() {\n      return this.navigationTransitions.lastSuccessfulNavigation;\n    }\n    resetConfig(config) {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n      this.config = config.map(standardizeConfig);\n      this.navigated = false;\n    }\n    ngOnDestroy() {\n      this.dispose();\n    }\n    dispose() {\n      this._events.unsubscribe();\n      this.navigationTransitions.complete();\n      this.nonRouterCurrentEntryChangeSubscription?.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n      this.disposed = true;\n      this.eventsSubscription.unsubscribe();\n    }\n    createUrlTree(commands, navigationExtras = {}) {\n      const {\n        relativeTo,\n        queryParams,\n        fragment,\n        queryParamsHandling,\n        preserveFragment\n      } = navigationExtras;\n      const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n      let q = null;\n      switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n        case 'merge':\n          q = {\n            ...this.currentUrlTree.queryParams,\n            ...queryParams\n          };\n          break;\n        case 'preserve':\n          q = this.currentUrlTree.queryParams;\n          break;\n        default:\n          q = queryParams || null;\n      }\n      if (q !== null) {\n        q = this.removeEmptyProps(q);\n      }\n      let relativeToUrlSegmentGroup;\n      try {\n        const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n        relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n      } catch (e) {\n        if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n          commands = [];\n        }\n        relativeToUrlSegmentGroup = this.currentUrlTree.root;\n      }\n      return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null, this.urlSerializer);\n    }\n    navigateByUrl(url, extras = {\n      skipLocationChange: false\n    }) {\n      const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n      const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n      return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n    }\n    navigate(commands, extras = {\n      skipLocationChange: false\n    }) {\n      validateCommands(commands);\n      return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    }\n    serializeUrl(url) {\n      return this.urlSerializer.serialize(url);\n    }\n    parseUrl(url) {\n      try {\n        return this.urlSerializer.parse(url);\n      } catch (e) {\n        this.console.warn(_formatRuntimeError(4018, ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. \\n` + e));\n        return this.urlSerializer.parse('/');\n      }\n    }\n    isActive(url, matchOptions) {\n      let options;\n      if (matchOptions === true) {\n        options = {\n          ...exactMatchOptions\n        };\n      } else if (matchOptions === false) {\n        options = {\n          ...subsetMatchOptions\n        };\n      } else {\n        options = matchOptions;\n      }\n      if (isUrlTree(url)) {\n        return containsTree(this.currentUrlTree, url, options);\n      }\n      const urlTree = this.parseUrl(url);\n      return containsTree(this.currentUrlTree, urlTree, options);\n    }\n    removeEmptyProps(params) {\n      return Object.entries(params).reduce((result, [key, value]) => {\n        if (value !== null && value !== undefined) {\n          result[key] = value;\n        }\n        return result;\n      }, {});\n    }\n    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n      if (this.disposed) {\n        return Promise.resolve(false);\n      }\n      let resolve;\n      let reject;\n      let promise;\n      if (priorPromise) {\n        resolve = priorPromise.resolve;\n        reject = priorPromise.reject;\n        promise = priorPromise.promise;\n      } else {\n        promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n      }\n      const taskId = this.pendingTasks.add();\n      afterNextNavigation(this, () => {\n        queueMicrotask(() => this.pendingTasks.remove(taskId));\n      });\n      this.navigationTransitions.handleNavigationRequest({\n        source,\n        restoredState,\n        currentUrlTree: this.currentUrlTree,\n        currentRawUrl: this.currentUrlTree,\n        rawUrl,\n        extras,\n        resolve: resolve,\n        reject: reject,\n        promise,\n        currentSnapshot: this.routerState.snapshot,\n        currentRouterState: this.routerState\n      });\n      return promise.catch(e => {\n        return Promise.reject(e);\n      });\n    }\n    static ɵfac = function Router_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Router)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Router,\n      factory: Router.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Router;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction validateCommands(commands) {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new _RuntimeError(4008, (typeof ngDevMode === 'undefined' || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, BeforeActivateRoutes, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, IMPERATIVE_NAVIGATION, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, ROUTE_INJECTOR_CLEANUP, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, StateManager, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, destroyDetachedRouteHandle, exactMatchOptions, isActive, isRedirectingEvent, isUrlTree, loadChildren, routeInjectorCleanup, stringifyEvent, subsetMatchOptions, ɵEmptyOutletComponent };\n","/**\n * @license Angular v21.1.2\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i3 from '@angular/common';\nimport { ViewportScroller, PlatformNavigation, PlatformLocation, ɵPRECOMMIT_HANDLER_SUPPORTED as _PRECOMMIT_HANDLER_SUPPORTED, Location, ɵNavigationAdapterForLocation as _NavigationAdapterForLocation, LOCATION_INITIALIZED, LocationStrategy, HashLocationStrategy, PathLocationStrategy } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { signal, untracked, inject, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, HostAttributeToken, ɵRuntimeError as _RuntimeError, booleanAttribute, Directive, Attribute, HostBinding, Input, HostListener, EventEmitter, ContentChildren, Output, Injectable, createEnvironmentInjector, InjectionToken, NgZone, EnvironmentInjector, DestroyRef, afterNextRender, ɵpromiseWithResolvers as _promiseWithResolvers, ɵpublishExternalGlobalUtil as _publishExternalGlobalUtil, makeEnvironmentProviders, APP_BOOTSTRAP_LISTENER, provideEnvironmentInitializer, Injector, ApplicationRef, ɵIS_ENABLED_BLOCKING_INITIAL_NAVIGATION as _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, provideAppInitializer, ɵperformanceMarkFeature as _performanceMarkFeature, ENVIRONMENT_INITIALIZER, NgModule } from '@angular/core';\nimport { ROUTER_CONFIGURATION, NavigationEnd, isUrlTree, Router, ActivatedRoute, isActive, exactMatchOptions, subsetMatchOptions, RouterConfigLoader, IMPERATIVE_NAVIGATION, UrlSerializer, NavigationTransitions, NavigationStart, NavigationSkipped, NavigationSkippedCode, Scroll, StateManager, RoutesRecognized, BeforeActivateRoutes, NavigationCancel, NavigationError, isRedirectingEvent, NavigationCancellationCode, ROUTES, afterNextNavigation, ROUTE_INJECTOR_CLEANUP, routeInjectorCleanup, stringifyEvent, NAVIGATION_ERROR_HANDLER, RoutedComponentInputBinder, INPUT_BINDER, CREATE_VIEW_TRANSITION, createViewTransition, VIEW_TRANSITION_OPTIONS, DefaultUrlSerializer, ChildrenOutletContexts, RouterOutlet, ɵEmptyOutletComponent as _EmptyOutletComponent } from './_router-chunk.mjs';\nimport { Subject, of, from } from 'rxjs';\nimport { mergeAll, catchError, filter, concatMap, mergeMap } from 'rxjs/operators';\nlet RouterLink = /*#__PURE__*/(() => {\n  class RouterLink {\n    router;\n    route;\n    tabIndexAttribute;\n    renderer;\n    el;\n    locationStrategy;\n    reactiveHref = signal(null, ...(ngDevMode ? [{\n      debugName: \"reactiveHref\"\n    }] : []));\n    get href() {\n      return untracked(this.reactiveHref);\n    }\n    set href(value) {\n      this.reactiveHref.set(value);\n    }\n    target;\n    queryParams;\n    fragment;\n    queryParamsHandling;\n    state;\n    info;\n    relativeTo;\n    isAnchorElement;\n    subscription;\n    onChanges = new Subject();\n    applicationErrorHandler = inject(_INTERNAL_APPLICATION_ERROR_HANDLER);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    });\n    constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {\n      this.router = router;\n      this.route = route;\n      this.tabIndexAttribute = tabIndexAttribute;\n      this.renderer = renderer;\n      this.el = el;\n      this.locationStrategy = locationStrategy;\n      this.reactiveHref.set(inject(new HostAttributeToken('href'), {\n        optional: true\n      }));\n      const tagName = el.nativeElement.tagName?.toLowerCase();\n      this.isAnchorElement = tagName === 'a' || tagName === 'area' || !!(typeof customElements === 'object' && customElements.get(tagName)?.observedAttributes?.includes?.('href'));\n      if (this.isAnchorElement) {\n        this.setTabIndexIfNotOnNativeEl('0');\n        this.subscribeToNavigationEventsIfNecessary();\n      }\n    }\n    subscribeToNavigationEventsIfNecessary() {\n      if (this.subscription !== undefined) {\n        return;\n      }\n      this.subscription = this.router.events.subscribe(s => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    }\n    preserveFragment = false;\n    skipLocationChange = false;\n    replaceUrl = false;\n    setTabIndexIfNotOnNativeEl(newTabIndex) {\n      if (this.tabIndexAttribute != null || this.isAnchorElement) {\n        return;\n      }\n      this.applyAttributeValue('tabindex', newTabIndex);\n    }\n    ngOnChanges(changes) {\n      if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== undefined || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {\n        throw new _RuntimeError(4017, 'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.');\n      }\n      if (this.isAnchorElement) {\n        this.updateHref();\n      }\n      this.onChanges.next(this);\n    }\n    routerLinkInput = null;\n    set routerLink(commandsOrUrlTree) {\n      if (commandsOrUrlTree == null) {\n        this.routerLinkInput = null;\n        this.setTabIndexIfNotOnNativeEl(null);\n      } else {\n        if (isUrlTree(commandsOrUrlTree)) {\n          this.routerLinkInput = commandsOrUrlTree;\n        } else {\n          this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];\n        }\n        this.setTabIndexIfNotOnNativeEl('0');\n      }\n    }\n    onClick(button, ctrlKey, shiftKey, altKey, metaKey) {\n      const urlTree = this.urlTree;\n      if (urlTree === null) {\n        return true;\n      }\n      if (this.isAnchorElement) {\n        if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n          return true;\n        }\n        if (typeof this.target === 'string' && this.target != '_self') {\n          return true;\n        }\n      }\n      const extras = {\n        skipLocationChange: this.skipLocationChange,\n        replaceUrl: this.replaceUrl,\n        state: this.state,\n        info: this.info\n      };\n      this.router.navigateByUrl(urlTree, extras)?.catch(e => {\n        this.applicationErrorHandler(e);\n      });\n      return !this.isAnchorElement;\n    }\n    ngOnDestroy() {\n      this.subscription?.unsubscribe();\n    }\n    updateHref() {\n      const urlTree = this.urlTree;\n      this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? '' : null);\n    }\n    applyAttributeValue(attrName, attrValue) {\n      const renderer = this.renderer;\n      const nativeElement = this.el.nativeElement;\n      if (attrValue !== null) {\n        renderer.setAttribute(nativeElement, attrName, attrValue);\n      } else {\n        renderer.removeAttribute(nativeElement, attrName);\n      }\n    }\n    get urlTree() {\n      if (this.routerLinkInput === null) {\n        return null;\n      } else if (isUrlTree(this.routerLinkInput)) {\n        return this.routerLinkInput;\n      }\n      return this.router.createUrlTree(this.routerLinkInput, {\n        relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n        queryParams: this.queryParams,\n        fragment: this.fragment,\n        queryParamsHandling: this.queryParamsHandling,\n        preserveFragment: this.preserveFragment\n      });\n    }\n    static ɵfac = function RouterLink_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterLink)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(ActivatedRoute), i0.ɵɵinjectAttribute('tabindex'), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.LocationStrategy));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterLink,\n      selectors: [[\"\", \"routerLink\", \"\"]],\n      hostVars: 2,\n      hostBindings: function RouterLink_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function RouterLink_click_HostBindingHandler($event) {\n            return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"href\", ctx.reactiveHref(), i0.ɵɵsanitizeUrlOrResourceUrl)(\"target\", ctx.target);\n        }\n      },\n      inputs: {\n        target: \"target\",\n        queryParams: \"queryParams\",\n        fragment: \"fragment\",\n        queryParamsHandling: \"queryParamsHandling\",\n        state: \"state\",\n        info: \"info\",\n        relativeTo: \"relativeTo\",\n        preserveFragment: [2, \"preserveFragment\", \"preserveFragment\", booleanAttribute],\n        skipLocationChange: [2, \"skipLocationChange\", \"skipLocationChange\", booleanAttribute],\n        replaceUrl: [2, \"replaceUrl\", \"replaceUrl\", booleanAttribute],\n        routerLink: \"routerLink\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterLink;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RouterLinkActive = /*#__PURE__*/(() => {\n  class RouterLinkActive {\n    router;\n    element;\n    renderer;\n    cdr;\n    links;\n    classes = [];\n    routerEventsSubscription;\n    linkInputChangesSubscription;\n    _isActive = false;\n    get isActive() {\n      return this._isActive;\n    }\n    routerLinkActiveOptions = {\n      exact: false\n    };\n    ariaCurrentWhenActive;\n    isActiveChange = new EventEmitter();\n    link = inject(RouterLink, {\n      optional: true\n    });\n    constructor(router, element, renderer, cdr) {\n      this.router = router;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.routerEventsSubscription = router.events.subscribe(s => {\n        if (s instanceof NavigationEnd) {\n          this.update();\n        }\n      });\n    }\n    ngAfterContentInit() {\n      of(this.links.changes, of(null)).pipe(mergeAll()).subscribe(_ => {\n        this.update();\n        this.subscribeToEachLinkOnChanges();\n      });\n    }\n    subscribeToEachLinkOnChanges() {\n      this.linkInputChangesSubscription?.unsubscribe();\n      const allLinkChanges = [...this.links.toArray(), this.link].filter(link => !!link).map(link => link.onChanges);\n      this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(link => {\n        if (this._isActive !== this.isLinkActive(this.router)(link)) {\n          this.update();\n        }\n      });\n    }\n    set routerLinkActive(data) {\n      const classes = Array.isArray(data) ? data : data.split(' ');\n      this.classes = classes.filter(c => !!c);\n    }\n    ngOnChanges(changes) {\n      this.update();\n    }\n    ngOnDestroy() {\n      this.routerEventsSubscription.unsubscribe();\n      this.linkInputChangesSubscription?.unsubscribe();\n    }\n    update() {\n      if (!this.links || !this.router.navigated) return;\n      queueMicrotask(() => {\n        const hasActiveLinks = this.hasActiveLinks();\n        this.classes.forEach(c => {\n          if (hasActiveLinks) {\n            this.renderer.addClass(this.element.nativeElement, c);\n          } else {\n            this.renderer.removeClass(this.element.nativeElement, c);\n          }\n        });\n        if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n          this.renderer.setAttribute(this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());\n        } else {\n          this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n        }\n        if (this._isActive !== hasActiveLinks) {\n          this._isActive = hasActiveLinks;\n          this.cdr.markForCheck();\n          this.isActiveChange.emit(hasActiveLinks);\n        }\n      });\n    }\n    isLinkActive(router) {\n      const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact ?? false ? {\n        ...exactMatchOptions\n      } : {\n        ...subsetMatchOptions\n      };\n      return link => {\n        const urlTree = link.urlTree;\n        return urlTree ? untracked(isActive(urlTree, router, options)) : false;\n      };\n    }\n    hasActiveLinks() {\n      const isActiveCheckFn = this.isLinkActive(this.router);\n      return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);\n    }\n    static ɵfac = function RouterLinkActive_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterLinkActive)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterLinkActive,\n      selectors: [[\"\", \"routerLinkActive\", \"\"]],\n      contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, RouterLink, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.links = _t);\n        }\n      },\n      inputs: {\n        routerLinkActiveOptions: \"routerLinkActiveOptions\",\n        ariaCurrentWhenActive: \"ariaCurrentWhenActive\",\n        routerLinkActive: \"routerLinkActive\"\n      },\n      outputs: {\n        isActiveChange: \"isActiveChange\"\n      },\n      exportAs: [\"routerLinkActive\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterLinkActive;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isActiveMatchOptions(options) {\n  return !!options.paths;\n}\nclass PreloadingStrategy {}\nlet PreloadAllModules = /*#__PURE__*/(() => {\n  class PreloadAllModules {\n    preload(route, fn) {\n      return fn().pipe(catchError(() => of(null)));\n    }\n    static ɵfac = function PreloadAllModules_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PreloadAllModules)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PreloadAllModules,\n      factory: PreloadAllModules.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PreloadAllModules;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NoPreloading = /*#__PURE__*/(() => {\n  class NoPreloading {\n    preload(route, fn) {\n      return of(null);\n    }\n    static ɵfac = function NoPreloading_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NoPreloading)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NoPreloading,\n      factory: NoPreloading.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NoPreloading;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RouterPreloader = /*#__PURE__*/(() => {\n  class RouterPreloader {\n    router;\n    injector;\n    preloadingStrategy;\n    loader;\n    subscription;\n    constructor(router, injector, preloadingStrategy, loader) {\n      this.router = router;\n      this.injector = injector;\n      this.preloadingStrategy = preloadingStrategy;\n      this.loader = loader;\n    }\n    setUpPreloading() {\n      this.subscription = this.router.events.pipe(filter(e => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {});\n    }\n    preload() {\n      return this.processRoutes(this.injector, this.router.config);\n    }\n    ngOnDestroy() {\n      this.subscription?.unsubscribe();\n    }\n    processRoutes(injector, routes) {\n      const res = [];\n      for (const route of routes) {\n        if (route.providers && !route._injector) {\n          route._injector = createEnvironmentInjector(route.providers, injector, typeof ngDevMode === 'undefined' || ngDevMode ? `Route: ${route.path}` : '');\n        }\n        const injectorForCurrentRoute = route._injector ?? injector;\n        if (route._loadedNgModuleFactory && !route._loadedInjector) {\n          route._loadedInjector = route._loadedNgModuleFactory.create(injectorForCurrentRoute).injector;\n        }\n        const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n        if (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined || route.loadComponent && !route._loadedComponent) {\n          res.push(this.preloadConfig(injectorForCurrentRoute, route));\n        }\n        if (route.children || route._loadedRoutes) {\n          res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));\n        }\n      }\n      return from(res).pipe(mergeAll());\n    }\n    preloadConfig(injector, route) {\n      return this.preloadingStrategy.preload(route, () => {\n        if (injector.destroyed) {\n          return of(null);\n        }\n        let loadedChildren$;\n        if (route.loadChildren && route.canLoad === undefined) {\n          loadedChildren$ = from(this.loader.loadChildren(injector, route));\n        } else {\n          loadedChildren$ = of(null);\n        }\n        const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap(config => {\n          if (config === null) {\n            return of(void 0);\n          }\n          route._loadedRoutes = config.routes;\n          route._loadedInjector = config.injector;\n          route._loadedNgModuleFactory = config.factory;\n          return this.processRoutes(config.injector ?? injector, config.routes);\n        }));\n        if (route.loadComponent && !route._loadedComponent) {\n          const loadComponent$ = this.loader.loadComponent(injector, route);\n          return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n        } else {\n          return recursiveLoadChildren$;\n        }\n      });\n    }\n    static ɵfac = function RouterPreloader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterPreloader)(i0.ɵɵinject(Router), i0.ɵɵinject(i0.EnvironmentInjector), i0.ɵɵinject(PreloadingStrategy), i0.ɵɵinject(RouterConfigLoader));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterPreloader,\n      factory: RouterPreloader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RouterPreloader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ROUTER_SCROLLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router Scroller' : '');\nlet RouterScroller = /*#__PURE__*/(() => {\n  class RouterScroller {\n    options;\n    routerEventsSubscription;\n    scrollEventsSubscription;\n    lastId = 0;\n    lastSource = IMPERATIVE_NAVIGATION;\n    restoredId = 0;\n    store = {};\n    urlSerializer = inject(UrlSerializer);\n    zone = inject(NgZone);\n    viewportScroller = inject(ViewportScroller);\n    transitions = inject(NavigationTransitions);\n    constructor(options) {\n      this.options = options;\n      this.options.scrollPositionRestoration ||= 'disabled';\n      this.options.anchorScrolling ||= 'disabled';\n    }\n    init() {\n      if (this.options.scrollPositionRestoration !== 'disabled') {\n        this.viewportScroller.setHistoryScrollRestoration('manual');\n      }\n      this.routerEventsSubscription = this.createScrollEvents();\n      this.scrollEventsSubscription = this.consumeScrollEvents();\n    }\n    createScrollEvents() {\n      return this.transitions.events.subscribe(e => {\n        if (e instanceof NavigationStart) {\n          this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n          this.lastSource = e.navigationTrigger;\n          this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n        } else if (e instanceof NavigationEnd) {\n          this.lastId = e.id;\n          this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n        } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {\n          this.lastSource = undefined;\n          this.restoredId = 0;\n          this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n        }\n      });\n    }\n    consumeScrollEvents() {\n      return this.transitions.events.subscribe(e => {\n        if (!(e instanceof Scroll) || e.scrollBehavior === 'manual') return;\n        const instantScroll = {\n          behavior: 'instant'\n        };\n        if (e.position) {\n          if (this.options.scrollPositionRestoration === 'top') {\n            this.viewportScroller.scrollToPosition([0, 0], instantScroll);\n          } else if (this.options.scrollPositionRestoration === 'enabled') {\n            this.viewportScroller.scrollToPosition(e.position, instantScroll);\n          }\n        } else {\n          if (e.anchor && this.options.anchorScrolling === 'enabled') {\n            this.viewportScroller.scrollToAnchor(e.anchor);\n          } else if (this.options.scrollPositionRestoration !== 'disabled') {\n            this.viewportScroller.scrollToPosition([0, 0]);\n          }\n        }\n      });\n    }\n    scheduleScrollEvent(routerEvent, anchor) {\n      const scroll = untracked(this.transitions.currentNavigation)?.extras.scroll;\n      this.zone.runOutsideAngular(async () => {\n        await new Promise(resolve => {\n          setTimeout(resolve);\n          if (typeof requestAnimationFrame !== 'undefined') {\n            requestAnimationFrame(resolve);\n          }\n        });\n        this.zone.run(() => {\n          this.transitions.events.next(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor, scroll));\n        });\n      });\n    }\n    ngOnDestroy() {\n      this.routerEventsSubscription?.unsubscribe();\n      this.scrollEventsSubscription?.unsubscribe();\n    }\n    static ɵfac = function RouterScroller_Factory(__ngFactoryType__) {\n      i0.ɵɵinvalidFactory();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterScroller,\n      factory: RouterScroller.ɵfac\n    });\n  }\n  return RouterScroller;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getLoadedRoutes(route) {\n  return route._loadedRoutes;\n}\nfunction getRouterInstance(injector) {\n  return injector.get(Router, null, {\n    optional: true\n  });\n}\nfunction navigateByUrl(router, url) {\n  if (!(router instanceof Router)) {\n    throw new Error('The provided router is not an Angular Router.');\n  }\n  return router.navigateByUrl(url);\n}\nlet NavigationStateManager = /*#__PURE__*/(() => {\n  class NavigationStateManager extends StateManager {\n    injector = inject(EnvironmentInjector);\n    navigation = inject(PlatformNavigation);\n    inMemoryScrollingEnabled = inject(ROUTER_SCROLLER, {\n      optional: true\n    }) !== null;\n    base = new URL(inject(PlatformLocation).href).origin;\n    appRootURL = new URL(this.location.prepareExternalUrl?.('/') ?? '/', this.base).href;\n    precommitHandlerSupported = inject(_PRECOMMIT_HANDLER_SUPPORTED);\n    activeHistoryEntry = this.navigation.currentEntry;\n    currentNavigation = {};\n    nonRouterCurrentEntryChangeSubject = new Subject();\n    nonRouterEntryChangeListener;\n    get registered() {\n      return this.nonRouterEntryChangeListener !== undefined && !this.nonRouterEntryChangeListener.closed;\n    }\n    constructor() {\n      super();\n      const navigateListener = event => {\n        this.handleNavigate(event);\n      };\n      this.navigation.addEventListener('navigate', navigateListener);\n      inject(DestroyRef).onDestroy(() => this.navigation.removeEventListener('navigate', navigateListener));\n    }\n    registerNonRouterCurrentEntryChangeListener(listener) {\n      this.activeHistoryEntry = this.navigation.currentEntry;\n      this.nonRouterEntryChangeListener = this.nonRouterCurrentEntryChangeSubject.subscribe(({\n        path,\n        state\n      }) => {\n        listener(path, state, 'popstate');\n      });\n      return this.nonRouterEntryChangeListener;\n    }\n    async handleRouterEvent(e, transition) {\n      this.currentNavigation = {\n        ...this.currentNavigation,\n        routerTransition: transition\n      };\n      if (e instanceof NavigationStart) {\n        this.updateStateMemento();\n      } else if (e instanceof NavigationSkipped) {\n        this.finishNavigation();\n        this.commitTransition(transition);\n      } else if (e instanceof RoutesRecognized) {\n        if (this.urlUpdateStrategy === 'eager' && !transition.extras.skipLocationChange) {\n          this.createNavigationForTransition(transition);\n        }\n      } else if (e instanceof BeforeActivateRoutes) {\n        this.commitTransition(transition);\n        if (this.urlUpdateStrategy === 'deferred' && !transition.extras.skipLocationChange) {\n          this.createNavigationForTransition(transition);\n        }\n      } else if (e instanceof NavigationCancel || e instanceof NavigationError) {\n        void this.cancel(transition, e);\n      } else if (e instanceof NavigationEnd) {\n        const {\n          resolveHandler,\n          removeAbortListener\n        } = this.currentNavigation;\n        this.currentNavigation = {};\n        removeAbortListener?.();\n        this.activeHistoryEntry = this.navigation.currentEntry;\n        afterNextRender({\n          read: () => resolveHandler?.()\n        }, {\n          injector: this.injector\n        });\n      }\n    }\n    createNavigationForTransition(transition) {\n      const {\n        navigationEvent\n      } = this.currentNavigation;\n      if (navigationEvent && navigationEvent.navigationType === 'traverse' && this.eventAndRouterDestinationsMatch(navigationEvent, transition)) {\n        return;\n      }\n      this.currentNavigation.removeAbortListener?.();\n      const path = this.createBrowserPath(transition);\n      this.navigate(path, transition);\n    }\n    navigate(internalPath, transition) {\n      const path = transition.extras.skipLocationChange ? this.navigation.currentEntry.url : this.location.prepareExternalUrl(internalPath);\n      const state = {\n        ...transition.extras.state,\n        navigationId: transition.id\n      };\n      const info = {\n        ɵrouterInfo: {\n          intercept: true\n        }\n      };\n      if (!this.navigation.transition && this.currentNavigation.navigationEvent) {\n        transition.extras.replaceUrl = false;\n      }\n      const history = this.location.isCurrentPathEqualTo(path) || transition.extras.replaceUrl || transition.extras.skipLocationChange ? 'replace' : 'push';\n      handleResultRejections(this.navigation.navigate(path, {\n        state,\n        history,\n        info\n      }));\n    }\n    finishNavigation() {\n      this.currentNavigation?.resolveHandler?.();\n      this.currentNavigation = {};\n    }\n    async cancel(transition, cause) {\n      this.currentNavigation.rejectNavigateEvent?.();\n      const clearedState = {};\n      this.currentNavigation = clearedState;\n      if (isRedirectingEvent(cause)) {\n        return;\n      }\n      const isTraversalReset = this.canceledNavigationResolution === 'computed' && this.navigation.currentEntry.key !== this.activeHistoryEntry.key;\n      this.resetInternalState(transition.finalUrl, isTraversalReset);\n      if (this.navigation.currentEntry.id === this.activeHistoryEntry.id) {\n        return;\n      }\n      if (cause instanceof NavigationCancel && cause.code === NavigationCancellationCode.Aborted) {\n        await Promise.resolve();\n        if (this.currentNavigation !== clearedState) {\n          return;\n        }\n      }\n      if (isTraversalReset) {\n        handleResultRejections(this.navigation.traverseTo(this.activeHistoryEntry.key, {\n          info: {\n            ɵrouterInfo: {\n              intercept: false\n            }\n          }\n        }));\n      } else {\n        const internalPath = this.urlSerializer.serialize(this.getCurrentUrlTree());\n        const pathOrUrl = this.location.prepareExternalUrl(internalPath);\n        handleResultRejections(this.navigation.navigate(pathOrUrl, {\n          state: this.activeHistoryEntry.getState(),\n          history: 'replace',\n          info: {\n            ɵrouterInfo: {\n              intercept: false\n            }\n          }\n        }));\n      }\n    }\n    resetInternalState(finalUrl, traversalReset) {\n      this.routerState = this.stateMemento.routerState;\n      this.currentUrlTree = this.stateMemento.currentUrlTree;\n      this.rawUrlTree = traversalReset ? this.stateMemento.rawUrlTree : this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n    }\n    handleNavigate(event) {\n      if (!event.canIntercept || event.navigationType === 'reload') {\n        return;\n      }\n      const routerInfo = event?.info?.ɵrouterInfo;\n      if (routerInfo && !routerInfo.intercept) {\n        return;\n      }\n      const isTriggeredByRouterTransition = !!routerInfo;\n      if (!isTriggeredByRouterTransition) {\n        this.currentNavigation.routerTransition?.abort();\n        if (!this.registered) {\n          this.finishNavigation();\n          return;\n        }\n      }\n      this.currentNavigation = {\n        ...this.currentNavigation\n      };\n      this.currentNavigation.navigationEvent = event;\n      const abortHandler = () => {\n        this.currentNavigation.routerTransition?.abort();\n      };\n      event.signal.addEventListener('abort', abortHandler);\n      this.currentNavigation.removeAbortListener = () => event.signal.removeEventListener('abort', abortHandler);\n      let scroll = this.inMemoryScrollingEnabled ? 'manual' : this.currentNavigation.routerTransition?.extras.scroll ?? 'after-transition';\n      const interceptOptions = {\n        scroll\n      };\n      const {\n        promise: handlerPromise,\n        resolve: resolveHandler,\n        reject: rejectHandler\n      } = _promiseWithResolvers();\n      this.currentNavigation.resolveHandler = () => {\n        this.currentNavigation.removeAbortListener?.();\n        resolveHandler();\n      };\n      this.currentNavigation.rejectNavigateEvent = () => {\n        this.currentNavigation.removeAbortListener?.();\n        rejectHandler();\n      };\n      handlerPromise.catch(() => {});\n      interceptOptions.handler = () => handlerPromise;\n      event.intercept(interceptOptions);\n      if (!isTriggeredByRouterTransition) {\n        this.handleNavigateEventTriggeredOutsideRouterAPIs(event);\n      }\n    }\n    handleNavigateEventTriggeredOutsideRouterAPIs(event) {\n      const path = event.destination.url.substring(this.appRootURL.length - 1);\n      const state = event.destination.getState();\n      this.nonRouterCurrentEntryChangeSubject.next({\n        path,\n        state\n      });\n    }\n    eventAndRouterDestinationsMatch(navigateEvent, transition) {\n      const internalPath = this.createBrowserPath(transition);\n      const eventDestination = new URL(navigateEvent.destination.url);\n      const routerDestination = this.location.prepareExternalUrl(internalPath);\n      return new URL(routerDestination, eventDestination.origin).href === eventDestination.href;\n    }\n    static ɵfac = function NavigationStateManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NavigationStateManager)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NavigationStateManager,\n      factory: NavigationStateManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NavigationStateManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction handleResultRejections(result) {\n  result.finished.catch(() => {});\n  result.committed.catch(() => {});\n  return result;\n}\nfunction provideRouter(routes, ...features) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _publishExternalGlobalUtil('ɵgetLoadedRoutes', getLoadedRoutes);\n    _publishExternalGlobalUtil('ɵgetRouterInstance', getRouterInstance);\n    _publishExternalGlobalUtil('ɵnavigateByUrl', navigateByUrl);\n  }\n  return makeEnvironmentProviders([{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }, typeof ngDevMode === 'undefined' || ngDevMode ? {\n    provide: ROUTER_IS_PROVIDED,\n    useValue: true\n  } : [], {\n    provide: ActivatedRoute,\n    useFactory: rootRoute\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: getBootstrapListener\n  }, features.map(feature => feature.ɵproviders)]);\n}\nfunction rootRoute() {\n  return inject(Router).routerState.root;\n}\nfunction routerFeature(kind, providers) {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers\n  };\n}\nconst ROUTER_IS_PROVIDED = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router is provided' : '', {\n  factory: () => false\n});\nconst routerIsProvidedDevModeCheck = {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => {\n      if (!inject(ROUTER_IS_PROVIDED)) {\n        console.warn('`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' + 'This is likely a mistake.');\n      }\n    };\n  }\n};\nfunction provideRoutes(routes) {\n  return [{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }, typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : []];\n}\nfunction withInMemoryScrolling(options = {}) {\n  const providers = [{\n    provide: ROUTER_SCROLLER,\n    useFactory: () => new RouterScroller(options)\n  }];\n  return routerFeature(4, providers);\n}\nfunction withExperimentalPlatformNavigation() {\n  const devModeLocationCheck = typeof ngDevMode === 'undefined' || ngDevMode ? [provideEnvironmentInitializer(() => {\n    const locationInstance = inject(Location);\n    if (!(locationInstance instanceof _NavigationAdapterForLocation)) {\n      const locationConstructorName = locationInstance.constructor.name;\n      let message = `'withExperimentalPlatformNavigation' provides a 'Location' implementation that ensures navigation APIs are consistently used.` + ` An instance of ${locationConstructorName} was found instead.`;\n      if (locationConstructorName === 'SpyLocation') {\n        message += ` One of 'RouterTestingModule' or 'provideLocationMocks' was likely used. 'withExperimentalPlatformNavigation' does not work with these because they override the Location implementation.`;\n      }\n      throw new Error(message);\n    }\n  })] : [];\n  const providers = [{\n    provide: StateManager,\n    useExisting: NavigationStateManager\n  }, {\n    provide: Location,\n    useClass: _NavigationAdapterForLocation\n  }, devModeLocationCheck];\n  return routerFeature(11, providers);\n}\nfunction getBootstrapListener() {\n  const injector = inject(Injector);\n  return bootstrappedComponentRef => {\n    const ref = injector.get(ApplicationRef);\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n    if (injector.get(INITIAL_NAVIGATION) === 1) {\n      router.initialNavigation();\n    }\n    injector.get(ROUTER_PRELOADER, null, {\n      optional: true\n    })?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, {\n      optional: true\n    })?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\nconst BOOTSTRAP_DONE = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '', {\n  factory: () => {\n    return new Subject();\n  }\n});\nconst INITIAL_NAVIGATION = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '', {\n  factory: () => 1\n});\nfunction withEnabledBlockingInitialNavigation() {\n  const providers = [{\n    provide: _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,\n    useValue: true\n  }, {\n    provide: INITIAL_NAVIGATION,\n    useValue: 0\n  }, provideAppInitializer(() => {\n    const injector = inject(Injector);\n    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());\n    return locationInitialized.then(() => {\n      return new Promise(resolve => {\n        const router = injector.get(Router);\n        const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n        afterNextNavigation(router, () => {\n          resolve(true);\n        });\n        injector.get(NavigationTransitions).afterPreactivation = () => {\n          resolve(true);\n          return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n        };\n        router.initialNavigation();\n      });\n    });\n  })];\n  return routerFeature(2, providers);\n}\nfunction withDisabledInitialNavigation() {\n  const providers = [provideAppInitializer(() => {\n    inject(Router).setUpLocationChangeListener();\n  }), {\n    provide: INITIAL_NAVIGATION,\n    useValue: 2\n  }];\n  return routerFeature(3, providers);\n}\nfunction withDebugTracing() {\n  let providers = [];\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    providers = [{\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => router.events.subscribe(e => {\n          console.group?.(`Router Event: ${e.constructor.name}`);\n          console.log(stringifyEvent(e));\n          console.log(e);\n          console.groupEnd?.();\n        });\n      }\n    }];\n  } else {\n    providers = [];\n  }\n  return routerFeature(1, providers);\n}\nconst ROUTER_PRELOADER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '');\nfunction withPreloading(preloadingStrategy) {\n  const providers = [{\n    provide: ROUTER_PRELOADER,\n    useExisting: RouterPreloader\n  }, {\n    provide: PreloadingStrategy,\n    useExisting: preloadingStrategy\n  }];\n  return routerFeature(0, providers);\n}\nfunction withRouterConfig(options) {\n  const providers = [{\n    provide: ROUTER_CONFIGURATION,\n    useValue: options\n  }];\n  return routerFeature(5, providers);\n}\nfunction withHashLocation() {\n  const providers = [{\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  }];\n  return routerFeature(6, providers);\n}\nfunction withNavigationErrorHandler(handler) {\n  const providers = [{\n    provide: NAVIGATION_ERROR_HANDLER,\n    useValue: handler\n  }];\n  return routerFeature(7, providers);\n}\nfunction withExperimentalAutoCleanupInjectors() {\n  return routerFeature(10, [{\n    provide: ROUTE_INJECTOR_CLEANUP,\n    useValue: routeInjectorCleanup\n  }]);\n}\nfunction withComponentInputBinding() {\n  const providers = [RoutedComponentInputBinder, {\n    provide: INPUT_BINDER,\n    useExisting: RoutedComponentInputBinder\n  }];\n  return routerFeature(8, providers);\n}\nfunction withViewTransitions(options) {\n  _performanceMarkFeature('NgRouterViewTransitions');\n  const providers = [{\n    provide: CREATE_VIEW_TRANSITION,\n    useValue: createViewTransition\n  }, {\n    provide: VIEW_TRANSITION_OPTIONS,\n    useValue: {\n      skipNextTransition: !!options?.skipInitialTransition,\n      ...options\n    }\n  }];\n  return routerFeature(9, providers);\n}\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, _EmptyOutletComponent];\nconst ROUTER_FORROOT_GUARD = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router duplicate forRoot guard' : '');\nconst ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, Router, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute\n}, RouterConfigLoader, typeof ngDevMode === 'undefined' || ngDevMode ? {\n  provide: ROUTER_IS_PROVIDED,\n  useValue: true\n} : []];\nlet RouterModule = /*#__PURE__*/(() => {\n  class RouterModule {\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        inject(ROUTER_FORROOT_GUARD, {\n          optional: true\n        });\n      }\n    }\n    static forRoot(routes, config) {\n      return {\n        ngModule: RouterModule,\n        providers: [ROUTER_PROVIDERS, typeof ngDevMode === 'undefined' || ngDevMode ? config?.enableTracing ? withDebugTracing().ɵproviders : [] : [], {\n          provide: ROUTES,\n          multi: true,\n          useValue: routes\n        }, typeof ngDevMode === 'undefined' || ngDevMode ? {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard\n        } : [], config?.errorHandler ? {\n          provide: NAVIGATION_ERROR_HANDLER,\n          useValue: config.errorHandler\n        } : [], {\n          provide: ROUTER_CONFIGURATION,\n          useValue: config ? config : {}\n        }, config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).ɵproviders : [], config?.initialNavigation ? provideInitialNavigation(config) : [], config?.bindToComponentInputs ? withComponentInputBinding().ɵproviders : [], config?.enableViewTransitions ? withViewTransitions().ɵproviders : [], provideRouterInitializer()]\n      };\n    }\n    static forChild(routes) {\n      return {\n        ngModule: RouterModule,\n        providers: [{\n          provide: ROUTES,\n          multi: true,\n          useValue: routes\n        }]\n      };\n    }\n    static ɵfac = function RouterModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: RouterModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return RouterModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideRouterScroller() {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const config = inject(ROUTER_CONFIGURATION);\n      if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n      }\n      return new RouterScroller(config);\n    }\n  };\n}\nfunction provideHashLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  };\n}\nfunction providePathLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: PathLocationStrategy\n  };\n}\nfunction provideForRootGuard() {\n  const router = inject(Router, {\n    optional: true,\n    skipSelf: true\n  });\n  if (router) {\n    throw new _RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` + ` Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return 'guarded';\n}\nfunction provideInitialNavigation(config) {\n  return [config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [], config.initialNavigation === 'enabledBlocking' ? withEnabledBlockingInitialNavigation().ɵproviders : []];\n}\nconst ROUTER_INITIALIZER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Router Initializer' : '');\nfunction provideRouterInitializer() {\n  return [{\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\nexport { NoPreloading, PreloadAllModules, PreloadingStrategy, ROUTER_INITIALIZER, ROUTER_PROVIDERS, RouterLink, RouterLinkActive, RouterModule, RouterPreloader, provideRouter, provideRoutes, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withExperimentalAutoCleanupInjectors, withExperimentalPlatformNavigation, withHashLocation, withInMemoryScrolling, withNavigationErrorHandler, withPreloading, withRouterConfig, withViewTransitions };\n"],"mappings":"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","names":["EventManagerPlugin","_doc","DomEventsPlugin","doc","eventName","element","handler","options","target","callback","__ngFactoryType__","ɵɵinject","DOCUMENT","ɵɵdefineInjectable","EVENT_MANAGER_PLUGINS","InjectionToken","EventManager","plugins","_zone","plugin","otherPlugins","p","domEventPlugin","RuntimeError","NgZone","APP_ID_ATTRIBUTE_NAME","removeElements","elements","createStyleElement","style","styleElement","addServerStyles","appId","inline","external","createLinkElement","url","linkElement","SharedStylesHost","nonce","platformId","styles","urls","value","usages","creator","record","host","hostNode","APP_ID","CSP_NONCE","PLATFORM_ID","NAMESPACE_URIS","COMPONENT_REGEX","COMPONENT_VARIABLE","HOST_ATTR","CONTENT_ATTR","REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT","REMOVE_STYLES_ON_COMPONENT_DESTROY","InjectionToken","shimContentAttribute","componentShortId","COMPONENT_REGEX","shimHostAttribute","shimStylesContent","compId","styles","s","DomRendererFactory2","eventManager","sharedStylesHost","appId","removeStylesOnCompDestroy","doc","ngZone","nonce","tracingService","DefaultDomRenderer2","element","type","renderer","EmulatedEncapsulationDomRenderer2","NoneEncapsulationDomRenderer","rendererByCompId","ViewEncapsulation","ShadowDomRenderer","componentId","__ngFactoryType__","ɵɵinject","EventManager","SharedStylesHost","APP_ID","REMOVE_STYLES_ON_COMPONENT_DESTROY","DOCUMENT","NgZone","CSP_NONCE","TracingService","ɵɵdefineInjectable","name","namespace","NAMESPACE_URIS","value","parent","newChild","isTemplateNode","refChild","_parent","oldChild","selectorOrNode","preserveContent","el","RuntimeError","node","namespaceUri","style","flags","RendererStyleFlags2","target","event","callback","options","getDOM","wrappedCallback","eventHandler","isTemplateNode","node","ShadowDomRenderer","DefaultDomRenderer2","eventManager","hostEl","component","doc","ngZone","nonce","tracingService","sharedStylesHost","styles","shimStylesContent","style","styleEl","styleUrls","styleUrl","linkEl","createLinkElement","parent","newChild","refChild","_parent","oldChild","NoneEncapsulationDomRenderer","removeStylesOnCompDestroy","compId","allLeavingAnimations","EmulatedEncapsulationDomRenderer2","appId","shimContentAttribute","shimHostAttribute","element","name","el","BrowserDomAdapter","_BrowserDomAdapter","DomAdapter","setRootDomAdapter","el","evt","listener","options","node","tagName","doc","target","href","getBaseElementHref","relativePath","baseElement","name","parseCookieValue","url","BrowserXhr","__ngFactoryType__","ɵɵdefineInjectable","MODIFIER_KEYS","_keyMap","MODIFIER_KEY_GETTERS","event","KeyEventsPlugin","EventManagerPlugin","doc","eventName","element","handler","options","parsedEvent","outsideHandler","getDOM","parts","domEventName","key","fullKey","codeIX","modifierName","index","result","fullKeyCode","keycode","modifierGetter","zone","keyName","ɵɵinject","DOCUMENT","bootstrapApplication","rootComponent","context","config","__spreadValues","createProvidersConfig","internalCreateApplication","createProvidersConfig","options","context","BROWSER_MODULE_PROVIDERS","INTERNAL_BROWSER_PLATFORM_PROVIDERS","initDomAdapter","BrowserDomAdapter","errorHandler","ErrorHandler","_document","setDocument","INTERNAL_BROWSER_PLATFORM_PROVIDERS","PLATFORM_ID","PLATFORM_BROWSER_ID","PLATFORM_INITIALIZER","DOCUMENT","BROWSER_MODULE_PROVIDERS","INJECTOR_SCOPE","ErrorHandler","errorHandler","EVENT_MANAGER_PLUGINS","DomEventsPlugin","KeyEventsPlugin","DomRendererFactory2","SharedStylesHost","EventManager","RendererFactory2","XhrFactory","BrowserXhr","HttpHeaders","_HttpHeaders","headers","line","index","name","value","values","lcName","update","other","key","clone","base","toDelete","existing","headerValues","fn","TEXT_CONTENT_TYPE","JSON_CONTENT_TYPE","ACCEPT_HEADER_VALUE","HttpEventType","HttpResponseBase","init","defaultStatus","defaultStatusText","HttpHeaders","HttpResponse","_HttpResponse","HttpResponseBase","init","HttpEventType","update","HTTP_ROOT_INTERCEPTOR_FNS","InjectionToken","HTTP_TRANSFER_CACHE_ORIGIN_MAP","InjectionToken","BODY","HEADERS","STATUS","STATUS_TEXT","REQ_URL","RESPONSE_TYPE","CACHE_OPTIONS","ALLOWED_METHODS","transferCacheInterceptorFn","req","next","_a","inject","isCacheActive","globalOptions","__objRest","requestOptions","requestMethod","hasAuthHeaders","transferState","TransferState","RuntimeError","requestUrl","storeKey","makeCacheKey","response","headersToInclude","undecodedBody","responseType","httpHeaders","status","statusText","url","body","headers","HttpHeaders","of","HttpResponse","sortAndConcatParams","params","k","makeCacheKey","request","mappedRequestUrl","method","responseType","encodedParams","serializedBody","key","hash","generateHash","value","char","withHttpTransferCache","cacheOptions","CACHE_OPTIONS","performanceMarkFeature","__spreadValues","HTTP_ROOT_INTERCEPTOR_FNS","transferCacheInterceptorFn","APP_BOOTSTRAP_LISTENER","appRef","inject","ApplicationRef","cacheState","Title","_doc","newTitle","__ngFactoryType__","ɵɵinject","DOCUMENT","ɵɵdefineInjectable","HydrationFeatureKind","hydrationFeature","ɵkind","ɵproviders","ɵoptions","withEventReplay","hydrationFeature","HydrationFeatureKind","provideClientHydration","features","providers","featuresKind","ɵproviders","ɵkind","hasHttpTransferCacheOptions","HydrationFeatureKind","makeEnvironmentProviders","withDomHydration","withHttpTransferCache","PRIMARY_OUTLET","RouteTitleKey","ParamsAsMap","params","name","v","convertToParamMap","matchParts","routeParts","urlSegments","posParams","i","part","segment","defaultUrlMatcher","segments","segmentGroup","route","parts","wildcardIndex","consumed","pre","post","firstValueFrom","source","resolve","reject","first","value","err","shallowEqualArrays","a","b","shallowEqual","k1","getDataKeys","k2","key","equalArraysOrString","obj","aSorted","bSorted","val","index","last","wrapIntoObservable","isObservable","isPromise","from","of","wrapIntoPromise","pathCompareMap","equalSegmentGroups","containsSegmentGroup","paramCompareMap","equalParams","containsParams","containsTree","container","containee","options","pathCompareMap","paramCompareMap","equalParams","shallowEqual","equalSegmentGroups","matrixParams","equalPath","matrixParamsMatch","c","containsParams","key","equalArraysOrString","containsSegmentGroup","containsSegmentGroupHelper","containeePaths","current","next","PRIMARY_OUTLET","containerPaths","containeeSegment","UrlTree","root","UrlSegmentGroup","queryParams","fragment","convertToParamMap","DEFAULT_SERIALIZER","segments","children","v","serializePaths","UrlSegment","path","parameters","serializePath","equalSegments","as","bs","a","i","mapChildrenIntoArray","segment","fn","res","childOutlet","child","UrlSerializer","__ngFactoryType__","ɵɵdefineInjectable","DefaultUrlSerializer","url","p","UrlParser","tree","serializeSegment","query","serializeQueryParams","encodeUriFragment","primary","k","encodeUriString","s","encodeUriQuery","encodeUriSegment","decode","decodeQuery","serializeMatrixParams","params","value","strParams","name","SEGMENT_RE","matchSegments","str","match","MATRIX_PARAM_SEGMENT_RE","matchMatrixKeySegments","QUERY_PARAM_RE","matchQueryParams","QUERY_PARAM_VALUE_RE","matchUrlQueryParamValue","RuntimeError","valueMatch","decodedKey","decodedVal","currentVal","allowPrimary","outletName","createRoot","rootCandidate","squashSegmentGroup","segmentGroup","newChildren","childCandidate","grandChildOutlet","grandChild","mergeTrivialChildren","isUrlTree","createUrlTreeFromSnapshot","relativeTo","commands","urlSerializer","relativeToUrlSegmentGroup","createSegmentGroupFromRoute","createUrlTreeFromSegmentGroup","route","targetGroup","createSegmentGroupFromRouteRecursive","currentRoute","childOutlets","childSnapshot","rootSegmentGroup","nav","computeNavigation","position","findStartingPositionForTargetGroup","newSegmentGroup","updateSegmentGroupChildren","updateSegmentGroup","isMatrixParams","command","isCommandWithOutlets","normalizeQueryParams","oldRoot","oldSegmentGroup","qp","replaceSegment","newRoot","oldSegment","newSegment","Navigation","isAbsolute","numberOfDoubleDots","cmdWithOutlet","last","cmd","cmdIdx","outlets","urlPart","partIndex","Position","processChildren","index","target","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","getOutlets","startIndex","m","prefixedWith","slicedCommands","createNewSegmentGroup","childrenOfEmptyChild","outlet","currentCommandIndex","currentPathIndex","noMatch","curr","compare","paths","createNewSegmentChildren","stringify","IMPERATIVE_NAVIGATION","EventType","RouterEvent","id","NavigationStart","navigationTrigger","restoredState","NavigationEnd","urlAfterRedirects","NavigationCancellationCode","NavigationSkippedCode","NavigationCancel","reason","code","isRedirectingEvent","event","NavigationSkipped","NavigationError","error","RoutesRecognized","state","GuardsCheckStart","GuardsCheckEnd","shouldActivate","ResolveStart","ResolveEnd","RouteConfigLoadStart","RouteConfigLoadEnd","ChildActivationStart","snapshot","ChildActivationEnd","ActivationStart","ActivationEnd","BeforeActivateRoutes","RedirectRequest","url","navigationBehaviorOptions","isPublicRouterEvent","e","OutletContext","rootInjector","ChildrenOutletContexts","childName","outlet","context","contexts","__ngFactoryType__","ɵɵinject","EnvironmentInjector","ɵɵdefineInjectable","Tree","root","t","p","n","findNode","findPath","c","cc","s","value","node","child","path","TreeNode","children","nodeChildrenAsMap","map","RouterState","snapshot","setRouterState","createEmptyState","rootComponent","injector","createEmptyStateSnapshot","emptyUrl","BehaviorSubject","UrlSegment","emptyParams","emptyData","emptyQueryParams","fragment","activated","ActivatedRoute","PRIMARY_OUTLET","ActivatedRouteSnapshot","RouterStateSnapshot","urlSubject","paramsSubject","queryParamsSubject","fragmentSubject","dataSubject","component","futureSnapshot","d","RouteTitleKey","of","convertToParamMap","getInherited","route","parent","paramsInheritanceStrategy","inherited","routeConfig","__spreadValues","hasStaticTitle","url","params","queryParams","data","resolve","environmentInjector","segment","matched","serializeNode","state","advanceActivatedRoute","currentSnapshot","nextSnapshot","shallowEqual","shallowEqualArrays","equalParamsAndUrlSegments","a","b","equalUrlParams","equalSegments","parentsMismatch","config","ROUTER_OUTLET_DATA","InjectionToken","RouterOutlet","EventEmitter","input","inject","ViewContainerRef","ChangeDetectorRef","INPUT_BINDER","changes","firstChange","previousValue","outletName","RuntimeError","cmp","ref","activatedRoute","location","childContexts","OutletInjector","ɵɵdefineDirective","ɵɵNgOnChangesFeature","outletData","token","notFoundValue","ɵEmptyOutletComponent","__ngFactoryType__","ɵɵdefineComponent","rf","ctx","ɵɵelement","RouterOutlet","standardizeConfig","r","children","c","__spreadProps","__spreadValues","PRIMARY_OUTLET","createRouterState","routeReuseStrategy","curr","prevState","root","createNode","RouterState","value","createOrReuseChildren","TreeNode","detachedRouteHandle","tree","createActivatedRoute","child","p","ActivatedRoute","BehaviorSubject","RedirectCommand","redirectTo","navigationBehaviorOptions","NAVIGATION_CANCELING_ERROR","redirectingNavigationError","urlSerializer","redirect","isUrlTree","error","navigationCancelingError","NavigationCancellationCode","message","code","isRedirectingNavigationCancelingError","isNavigationCancelingError","ActivateRoutes","routeReuseStrategy","futureState","currState","forwardEvent","inputBindingEnabled","parentContexts","futureRoot","currRoot","advanceActivatedRoute","futureNode","currNode","contexts","children","nodeChildrenAsMap","futureChild","childOutletName","v","parentContext","future","curr","context","route","treeNode","componentRef","c","ActivationEnd","ChildActivationEnd","stored","CanActivate","path","CanDeactivate","component","getAllRouteGuards","getChildRouteGuards","getCanActivateChild","p","canActivateChild","getTokenOrFunctionIdentity","tokenOrFunction","injector","NOT_FOUND","result","isInjectable","futurePath","checks","prevChildren","getRouteGuards","k","deactivateRouteAndItsChildren","shouldRun","shouldRunGuardsAndResolvers","mode","runInInjectionContext","equalPath","shallowEqual","equalParamsAndUrlSegments","r","childName","node","isFunction","isBoolean","isCanLoad","guard","isCanActivate","isCanActivateChild","isCanDeactivate","isCanMatch","isEmptyError","e","EmptyError","INITIAL_VALUE","prioritizedGuardValue","switchMap","obs","combineLatest","o","take","startWith","map","results","isRedirect","filter","item","val","isUrlTree","RedirectCommand","abortSignalToObservable","signal","of","Observable","subscriber","handler","takeUntilAbort","takeUntil","checkGuards","mergeMap","t","targetSnapshot","currentSnapshot","canActivateChecks","canDeactivateChecks","__spreadProps","__spreadValues","runCanDeactivateChecks","canDeactivate","runCanActivateChecks","guardsResult","futureRSS","currRSS","from","check","runCanDeactivate","first","futureSnapshot","concatMap","concat","fireChildActivationStart","fireActivationStart","runCanActivateChild","runCanActivate","snapshot","ActivationStart","ChildActivationStart","futureARS","canActivate","canActivateObservables","defer","closestInjector","guardVal","wrapIntoObservable","canActivateChildGuardsMapped","_","d","guardsMapped","currARS","canDeactivateObservables","runCanLoadGuards","segments","urlSerializer","abortSignal","canLoad","canLoadObservables","injectionToken","obs$","redirectIfUrlTree","pipe","tap","redirectingNavigationError","runCanMatchGuards","canMatch","canMatchObservables","NoMatch","_NoMatch","segmentGroup","AbsoluteRedirect","_AbsoluteRedirect","urlTree","namedOutletsRedirect","redirectTo","RuntimeError","canLoadFails","navigationCancelingError","NavigationCancellationCode","ApplyRedirects","res","PRIMARY_OUTLET","posParams","redirect","getRedirectResult","UrlTree","newTree","newRoot","redirectToParams","actualParams","sourceName","group","updatedSegments","name","child","UrlSegmentGroup","redirectToSegments","actualSegments","s","redirectToUrlSegment","pos","idx","redirectToFn","queryParams","fragment","routeConfig","url","outlet","params","data","title","paramMap","queryParamMap","firstValueFrom","getOrCreateRouteInjectorIfNeeded","currentInjector","createEnvironmentInjector","getOutlet","route","PRIMARY_OUTLET","sortByMatchingOutlets","routes","outletName","sortedConfig","r","noMatch","matchWithChecks","segmentGroup","segments","injector","urlSerializer","abortSignal","result","match","getOrCreateRouteInjectorIfNeeded","runCanMatchGuards","map","v","__spreadValues","of","res","defaultUrlMatcher","posParams","k","parameters","split","consumedSegments","slicedSegments","config","containsEmptyPathMatchesWithNamedOutlets","UrlSegmentGroup","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","children","emptyPathMatch","primarySegment","s","noLeftoversInUrl","outlet","NoLeftoversInUrl","recognize$1","configLoader","rootComponentType","urlTree","paramsInheritanceStrategy","Recognizer","MAX_ALLOWED_REDIRECTS","ApplyRedirects","e","RuntimeError","rootSegmentGroup","rootSnapshot","rootNode","TreeNode","routeState","RouterStateSnapshot","tree","createUrlTreeFromSnapshot","ActivatedRouteSnapshot","AbsoluteRedirect","NoMatch","parentRoute","child","childOutlets","childOutlet","outletChildren","mergedChildren","mergeEmptyPathMatches","sortActivatedRouteSnapshots","allowRedirects","isEmptyError","rawSegment","matched","positionalParamSegments","remainingSegments","currentSnapshot","getData","getResolve","inherited","getInherited","newTree","newSegments","firstValueFrom","childConfig","childInjector","snapshot","matchedOnOutlet","ngModuleFactory","runCanLoadGuards","cfg","canLoadFails","nodes","a","b","hasEmptyPathConfig","node","mergedNodes","duplicateEmptyPathNode","resultNode","mergedNode","getData","route","getResolve","recognize","injector","configLoader","rootComponentType","config","serializer","paramsInheritanceStrategy","abortSignal","mergeMap","t","targetSnapshot","urlAfterRedirects","recognize$1","__spreadProps","__spreadValues","resolveData","canActivateChecks","of","routesWithResolversToRun","check","routesNeedingDataUpdates","newRoute","flattenRouteTree","routesProcessed","from","concatMap","runResolve","getInherited","tap","takeLast","_","EMPTY","descendants","child","futureARS","futureRSS","resolve","hasStaticTitle","RouteTitleKey","defer","resolveNode","map","resolvedData","keys","getDataKeys","data","key","getResolver","first","value","RedirectCommand","redirectingNavigationError","DefaultUrlSerializer","catchError","e","isEmptyError","throwError","injectionToken","closestInjector","resolver","getTokenOrFunctionIdentity","resolverValue","runInInjectionContext","wrapIntoObservable","switchTap","next","switchMap","v","nextResult","TitleStrategy","snapshot","pageTitle","PRIMARY_OUTLET","__ngFactoryType__","ɵɵdefineInjectable","inject","DefaultTitleStrategy","title","ɵɵinject","Title","ROUTER_CONFIGURATION","InjectionToken","ROUTES","RouterConfigLoader","Compiler","loader","loaded","wrapIntoPromise","component","maybeResolveResources","maybeUnwrapDefaultExport","parentInjector","result","loadChildren","compiler","onLoadEndListener","factoryOrRoutes","NgModuleFactory$1","rawRoutes","requireStandaloneComponents","factory","standardizeConfig","isWrappedDefaultExport","input","UrlHandlingStrategy","DefaultUrlHandlingStrategy","url","newUrlPart","wholeUrl","CREATE_VIEW_TRANSITION","noop","NAVIGATION_ERROR_HANDLER","InjectionToken","NavigationTransitions","signal","Subject","inject","RouterConfigLoader","EnvironmentInjector","DestroyRef","UrlSerializer","ChildrenOutletContexts","Location","INPUT_BINDER","TitleStrategy","ROUTER_CONFIGURATION","UrlHandlingStrategy","CREATE_VIEW_TRANSITION","of","onLoadStart","r","RouteConfigLoadStart","onLoadEnd","RouteConfigLoadEnd","request","id","untracked","__spreadProps","__spreadValues","router","BehaviorSubject","filter","t","switchMap","overallTransitionState","completedOrAborted","abortController","shouldContinueNavigation","NavigationCancellationCode","EMPTY","lastSuccessfulNavigation","urlTransition","onSameUrlNavigation","NavigationSkipped","NavigationSkippedCode","NavigationStart","recognize","tap","nav","routesRecognized","RoutesRecognized","extractedUrl","source","restoredState","extras","navStart","targetSnapshot","createEmptyState","map","guardsStart","GuardsCheckStart","getAllRouteGuards","checkGuards","evt","redirectingNavigationError","guardsEnd","GuardsCheckEnd","resolveStart","ResolveStart","dataResolved","resolveData","resolveEnd","ResolveEnd","switchTap","loadComponents","route","loaders","injector","loadedComponent","child","from","currentSnapshot","viewTransitionStarted","take","targetRouterState","createRouterState","BeforeActivateRoutes","ActivateRoutes","NavigationEnd","takeUntil","abortSignalToObservable","err","finalize","catchError","e","isNavigationCancelingError","NavigationCancel","isRedirectingNavigationCancelingError","RedirectRequest","navigationError","NavigationError","navigationErrorHandlerResult","runInInjectionContext","RedirectCommand","message","cancellationCode","ee","reason","code","navCancel","currentBrowserUrl","currentNavigation","targetBrowserUrl","__ngFactoryType__","ɵɵdefineInjectable","isBrowserTriggeredNavigation","IMPERATIVE_NAVIGATION","ROUTE_INJECTOR_CLEANUP","RouteReuseStrategy","__ngFactoryType__","ɵɵdefineInjectable","inject","DefaultRouteReuseStrategy","BaseRouteReuseStrategy","route","detachedTree","future","curr","ɵDefaultRouteReuseStrategy_BaseFactory","ɵɵgetInheritedFactory","StateManager","UrlSerializer","ROUTER_CONFIGURATION","Location","UrlHandlingStrategy","UrlTree","finalUrl","initialUrl","targetBrowserUrl","rawUrl","url","targetRouterState","createEmptyState","EnvironmentInjector","HistoryStateManager","listener","event","currentTransition","NavigationStart","NavigationSkipped","RoutesRecognized","BeforeActivateRoutes","NavigationCancel","isRedirectingEvent","NavigationError","NavigationEnd","path","extras","id","replaceUrl","state","currentBrowserPageId","newState","__spreadValues","navigation","restoringFromCaughtError","targetPagePosition","navigationId","routerPageId","ɵHistoryStateManager_BaseFactory","afterNextNavigation","router","action","filter","map","NavigationCancellationCode","result","take","exactMatchOptions","subsetMatchOptions","Router","Console","PendingTasksInternal","NavigationTransitions","Subject","ROUTE_INJECTOR_CLEANUP","ROUTES","INPUT_BINDER","Subscription","subscription","e","currentNavigation","untracked","RedirectRequest","opts","mergedTree","isBrowserTriggeredNavigation","IMPERATIVE_NAVIGATION","isPublicRouterEvent","rootComponentType","source","restoredState","stateCopy","urlTree","INTERNAL_APPLICATION_ERROR_HANDLER","config","standardizeConfig","commands","navigationExtras","relativeTo","queryParams","fragment","queryParamsHandling","preserveFragment","f","q","relativeToUrlSegmentGroup","relativeToSnapshot","createSegmentGroupFromRoute","createUrlTreeFromSegmentGroup","isUrlTree","validateCommands","formatRuntimeError","matchOptions","options","containsTree","params","key","value","priorPromise","resolve","reject","promise","res","rej","taskId","i","RuntimeError","ROUTER_SCROLLER","InjectionToken","provideRouter","routes","features","makeEnvironmentProviders","ROUTES","ActivatedRoute","rootRoute","APP_BOOTSTRAP_LISTENER","getBootstrapListener","feature","inject","Router","getBootstrapListener","injector","inject","Injector","bootstrappedComponentRef","ref","ApplicationRef","router","Router","bootstrapDone","BOOTSTRAP_DONE","INITIAL_NAVIGATION","ROUTER_PRELOADER","ROUTER_SCROLLER","InjectionToken","Subject","ROUTER_PRELOADER","InjectionToken"],"x_google_ignoreList":[0,1,2,3,4,5,6]}